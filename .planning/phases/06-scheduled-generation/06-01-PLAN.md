---
phase: 06-scheduled-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/worker/scheduler.go
  - internal/config/config.go
  - internal/worker/tasks.go
  - internal/worker/worker.go
  - cmd/server/main.go
autonomous: false

must_haves:
  truths:
    - "Scheduler starts automatically in both development and worker modes"
    - "Briefings are generated daily at configured time (default 6 AM UTC)"
    - "Schedule is configurable via BRIEFING_SCHEDULE environment variable"
    - "Scheduled generation creates briefing records for all users"
    - "Duplicate tasks are prevented via Unique option"
  artifacts:
    - path: "internal/worker/scheduler.go"
      provides: "Asynq Scheduler initialization with StartScheduler function"
      min_lines: 80
      exports: ["StartScheduler"]
    - path: "internal/config/config.go"
      provides: "BriefingSchedule and BriefingTimezone configuration fields"
      contains: "BriefingSchedule"
    - path: "internal/worker/tasks.go"
      provides: "TaskScheduledBriefingGeneration constant"
      contains: "TaskScheduledBriefingGeneration"
  key_links:
    - from: "cmd/server/main.go"
      to: "worker.StartScheduler"
      via: "Lifecycle management in both embedded and standalone modes"
      pattern: "StartScheduler\\(cfg\\)"
    - from: "internal/worker/scheduler.go"
      to: "TaskScheduledBriefingGeneration"
      via: "Scheduler registers periodic task with cron expression"
      pattern: "scheduler\\.Register.*TaskScheduledBriefingGeneration"
    - from: "internal/worker/worker.go"
      to: "handleScheduledBriefingGeneration"
      via: "Worker mux registers handler for scheduled task"
      pattern: "mux\\.HandleFunc\\(TaskScheduledBriefingGeneration"
---

<objective>
Implement automatic daily briefing generation using Asynq Scheduler with configurable cron schedule.

Purpose: Enable briefings to generate automatically on a daily schedule without manual user action, completing the core value proposition of waking up to a fresh briefing.

Output:
- Scheduler infrastructure with StartScheduler function
- Configuration fields for schedule and timezone
- Scheduled briefing generation handler that creates tasks for all users
- Scheduler lifecycle management in both development and worker modes
- End-to-end verification of scheduled generation
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-scheduled-generation/06-RESEARCH.md
@internal/worker/worker.go
@internal/worker/tasks.go
@internal/config/config.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scheduler infrastructure and config</name>
  <files>
    internal/worker/scheduler.go
    internal/config/config.go
    internal/worker/tasks.go
    internal/worker/worker.go
  </files>
  <action>
Create scheduler.go with StartScheduler function following research Pattern 1:
- Parse RedisURL and timezone from config (default "UTC")
- Create asynq.NewScheduler with SchedulerOpts.Location set to parsed timezone
- Use asynqLoggerAdapter (already exists in worker.go) for consistent logging
- Register periodic task with cfg.BriefingSchedule cron expression
- Create task with TaskScheduledBriefingGeneration type (empty payload)
- Add Unique(24*time.Hour) to prevent duplicate tasks if scheduler runs twice
- Call scheduler.Start() (non-blocking) and return stop function for Shutdown()
- Log schedule registration clearly: "Scheduler started with schedule: X (timezone: Y)"

Add to config.go Config struct and Load():
- BriefingSchedule string field with default "0 6 * * *" (6 AM daily)
- BriefingTimezone string field with default "UTC"
- Use getEnvWithDefault pattern consistent with existing config

Add to tasks.go:
- New constant: TaskScheduledBriefingGeneration = "briefing:scheduled_generation"

Add to worker.go newServer():
- Create handleScheduledBriefingGeneration handler function
- Query all users from database: db.Find(&users)
- For each user: create pending briefing record, call EnqueueGenerateBriefing(briefing.ID)
- Log success/error counts: "Scheduled briefing generation completed: X enqueued, Y errors"
- Return nil (don't fail task if some users fail - partial success acceptable)
- Register handler in mux: mux.HandleFunc(TaskScheduledBriefingGeneration, handleScheduledBriefingGeneration(...))

Modify tasks.go EnqueueGenerateBriefing():
- Add asynq.Unique(1*time.Hour) option to task creation
- Handle asynq.ErrDuplicateTask gracefully: log "Briefing X already queued (duplicate), skipping" and return nil (not an error)
- Import "errors" package for errors.Is check
  </action>
  <verify>
go build ./cmd/server
grep -q "StartScheduler" internal/worker/scheduler.go
grep -q "BriefingSchedule" internal/config/config.go
grep -q "TaskScheduledBriefingGeneration" internal/worker/tasks.go
grep -q "handleScheduledBriefingGeneration" internal/worker/worker.go
  </verify>
  <done>
- scheduler.go exists with StartScheduler function that returns stop function
- config.go has BriefingSchedule and BriefingTimezone fields with defaults
- tasks.go has TaskScheduledBriefingGeneration constant
- worker.go has handleScheduledBriefingGeneration registered in mux
- EnqueueGenerateBriefing has Unique option and handles ErrDuplicateTask
- Code compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire scheduler into main.go lifecycle</name>
  <files>
    cmd/server/main.go
    internal/worker/worker.go
  </files>
  <action>
Update cmd/server/main.go to start scheduler in both modes:

In worker mode (after line 84 "Starting in WORKER mode"):
- Call worker.StartScheduler(cfg) before worker.Run()
- Store returned stop function: stopScheduler, err := worker.StartScheduler(cfg)
- Defer stopScheduler() for cleanup
- worker.Run() is blocking, so scheduler will run until worker exits

In embedded development mode (after line 95 "Starting embedded worker"):
- Call worker.StartScheduler(cfg) after worker.Start()
- Store returned stop function: stopScheduler, err := worker.StartScheduler(cfg)
- Add scheduler shutdown in existing shutdown block (after line 219 "stopWorker()"): if stopScheduler != nil { stopScheduler() }

Update internal/worker/worker.go Run() function for standalone mode:
- Add scheduler lifecycle before srv.Run(mux)
- Call StartScheduler(cfg) and defer stop function
- Pattern: stopScheduler, err := StartScheduler(cfg); if err != nil { return err }; defer stopScheduler()
  </action>
  <verify>
grep -A5 "worker.StartScheduler" cmd/server/main.go | grep -q "stopScheduler"
go build ./cmd/server
  </verify>
  <done>
- main.go calls StartScheduler in both embedded mode and worker mode
- Scheduler shutdown is coordinated with worker shutdown
- worker.go Run() function includes scheduler lifecycle
- Code compiles without errors
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete scheduler integration and scheduled generation flow</name>
  <files>none</files>
  <action>
Human verifies complete Asynq Scheduler integration with automatic daily briefing generation:
- Scheduler infrastructure (scheduler.go)
- Configuration via BRIEFING_SCHEDULE and BRIEFING_TIMEZONE environment variables
- Scheduled task handler that generates briefings for all users
- Scheduler lifecycle management in both development and worker modes
- Duplicate prevention via Unique option

Verification steps:
1. Start application in development mode: make dev
   - Verify logs show "Starting embedded worker for development"
   - Verify logs show "Starting embedded scheduler for development"
   - Verify logs show "Scheduler started with schedule: 0 6 * * *" (or custom schedule)
   - Verify no errors in scheduler initialization

2. Test schedule configuration:
   - Stop server (Ctrl+C)
   - Set custom schedule: export BRIEFING_SCHEDULE="*/1 * * * *" (every minute for testing)
   - Set timezone: export BRIEFING_TIMEZONE="America/Los_Angeles"
   - Start server: make dev
   - Verify logs show new schedule: "Scheduler started with schedule: */1 * * * * (timezone: America/Los_Angeles)"
   - Wait 1-2 minutes and check logs for "Scheduled briefing generation completed" entries
   - Check Asynqmon (http://localhost:8081): Scheduled tab should show registered schedule
   - Check Asynqmon Processed tab for briefing:scheduled_generation tasks

3. Verify scheduled generation creates tasks:
   - After scheduled task runs, check logs for "Scheduled briefing generation completed: X enqueued, Y errors"
   - Check Asynqmon for multiple briefing:generate tasks (one per user)
   - Check database: psql $DATABASE_URL -c "SELECT id, user_id, status, created_at FROM briefings ORDER BY created_at DESC LIMIT 10;"
   - Verify new briefings exist with status='pending' or 'completed'

4. Test duplicate prevention:
   - Manually enqueue a briefing via dashboard "Generate Daily Summary" button
   - Wait for scheduled task to run (should be within 1 minute with test schedule)
   - Check logs for "Briefing X already queued (duplicate), skipping" messages
   - Verify only one briefing per user was created/processed

5. Test worker mode:
   - Stop dev server (Ctrl+C)
   - Unset test schedule: unset BRIEFING_SCHEDULE (revert to default 6 AM)
   - Start in worker mode: make worker
   - Verify logs show scheduler starting in standalone mode
   - Verify scheduler lifecycle works (Ctrl+C should exit cleanly)

6. Verify graceful shutdown:
   - Start dev server: make dev
   - Send SIGTERM: Ctrl+C
   - Verify logs show: "Shutting down..." → Scheduler shutdown → Worker shutdown → "Server stopped"
   - Process should exit within 2 seconds (not hanging)
  </action>
  <verify>
All 6 verification steps pass: scheduler starts in both modes, custom schedule respected, scheduled task enqueues briefings for all users, duplicate prevention works, graceful shutdown coordinates all components.
  </verify>
  <done>
Scheduler integration verified: automatic starts in dev/worker modes, configurable schedule via environment variables, scheduled generation creates briefing records for all users, duplicate prevention via Unique option works, Asynqmon shows registered schedule, graceful shutdown works.
  </done>
</task>

</tasks>

<verification>
Functional checks:
- Scheduler registers with configured cron expression (visible in Asynqmon)
- Scheduled task runs at specified intervals and creates briefing records for all users
- BRIEFING_SCHEDULE environment variable changes schedule without code modification
- BRIEFING_TIMEZONE environment variable sets correct timezone for cron interpretation
- Duplicate tasks are prevented by Unique option (ErrDuplicateTask handled gracefully)
- Scheduler lifecycle coordinates with worker in both embedded and standalone modes
- Graceful shutdown stops scheduler without goroutine leaks

Code quality checks:
- StartScheduler returns stop function for coordinated shutdown
- Error handling logs failures but doesn't panic
- Scheduled task handler doesn't fail entire task if individual user briefing fails (partial success)
- Configuration follows existing patterns (getEnvWithDefault)
- Logging uses structured slog patterns established in Phase 3
</verification>

<success_criteria>
Phase 6 is complete when:
- Scheduler automatically starts in development mode (embedded)
- Scheduler automatically starts in worker mode (standalone)
- Daily briefing generation occurs at configured time (default 6 AM UTC)
- BRIEFING_SCHEDULE environment variable configures cron schedule
- BRIEFING_TIMEZONE environment variable configures timezone
- Scheduled tasks create briefing records for all users
- Duplicate prevention via Unique option works correctly
- Graceful shutdown coordinates scheduler, worker, and HTTP server
- Asynqmon dashboard shows registered scheduler entries
- User verification checkpoint confirms end-to-end scheduled generation flow
</success_criteria>

<output>
After completion, create `.planning/phases/06-scheduled-generation/06-01-SUMMARY.md` using summary template.
</output>
