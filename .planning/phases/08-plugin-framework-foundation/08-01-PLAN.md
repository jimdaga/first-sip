---
phase: 08-plugin-framework-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/plugins/metadata.go
  - internal/plugins/discovery.go
  - internal/plugins/registry.go
autonomous: true

must_haves:
  truths:
    - "Plugin metadata can be parsed from a YAML file with name, description, owner, version, schema_version, capabilities, default_config, and settings_schema_path"
    - "Unknown YAML fields cause a parse error (not silently ignored)"
    - "Missing schema_version defaults to v1"
    - "Plugin discovery scans a directory and finds all subdirectories containing plugin.yaml"
    - "Invalid plugins are logged and skipped, not fatal"
    - "Plugin registry holds discovered plugins in memory, accessible by name"
  artifacts:
    - path: "internal/plugins/metadata.go"
      provides: "PluginMetadata struct with YAML tags, LoadPluginMetadata function using yaml.v3 decoder with KnownFields(true)"
      exports: ["PluginMetadata", "LoadPluginMetadata"]
    - path: "internal/plugins/discovery.go"
      provides: "DiscoverPlugins function scanning directory for plugin.yaml files"
      exports: ["DiscoverPlugins"]
    - path: "internal/plugins/registry.go"
      provides: "Registry struct with Get/List/Register methods, NewRegistry constructor"
      exports: ["Registry", "NewRegistry"]
  key_links:
    - from: "internal/plugins/discovery.go"
      to: "internal/plugins/metadata.go"
      via: "DiscoverPlugins calls LoadPluginMetadata for each found plugin.yaml"
      pattern: "LoadPluginMetadata"
    - from: "internal/plugins/registry.go"
      to: "internal/plugins/metadata.go"
      via: "Registry stores *PluginMetadata indexed by name"
      pattern: "PluginMetadata"
---

<objective>
Create the plugin metadata struct, YAML loading with strict validation, directory-based plugin discovery, and an in-memory plugin registry.

Purpose: Establishes the core plugin infrastructure that all other plugin features build on. Metadata defines what a plugin IS, discovery finds plugins on disk, and the registry makes them accessible at runtime.

Output: Three Go source files in internal/plugins/ providing the metadata, discovery, and registry layer.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-plugin-framework-foundation/08-RESEARCH.md
@internal/models/briefing.go
@internal/models/user.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Plugin metadata struct and YAML loader</name>
  <files>internal/plugins/metadata.go</files>
  <action>
Create `internal/plugins/` package directory and `metadata.go` file.

Define the `PluginMetadata` struct with these fields (all with `yaml:` struct tags):
- Name string (required)
- Description string
- Owner string
- Version string (required, semantic version like "1.0.0")
- SchemaVersion string (yaml:"schema_version", defaults to "v1" if empty after parsing)
- Capabilities []string
- DefaultConfig map[string]interface{} (yaml:"default_config")
- SettingsSchemaPath string (yaml:"settings_schema_path")

Create `LoadPluginMetadata(path string) (*PluginMetadata, error)` function:
1. Read file with os.ReadFile
2. Create yaml.NewDecoder from bytes.NewReader
3. Call decoder.KnownFields(true) -- CRITICAL for catching typos in YAML
4. Decode into PluginMetadata struct
5. If SchemaVersion is empty, set to "v1"
6. Validate required fields: Name and Version must be non-empty, return descriptive error if missing
7. Return the parsed metadata

Use gopkg.in/yaml.v3 (already available as transitive dependency in go.mod). Import bytes for NewReader.
  </action>
  <verify>
Create a temporary test YAML file and run `go build ./internal/plugins/` to confirm compilation. The struct and function signatures must compile cleanly.
  </verify>
  <done>
PluginMetadata struct defined with all fields. LoadPluginMetadata parses valid YAML, rejects unknown fields via KnownFields(true), defaults schema_version to "v1", and validates required fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Directory-based plugin discovery and in-memory registry</name>
  <files>internal/plugins/discovery.go, internal/plugins/registry.go</files>
  <action>
**discovery.go:**

Create `DiscoverPlugins(pluginDir string) ([]*PluginMetadata, error)` function:
1. Call os.ReadDir(pluginDir) to list directory entries
2. For each entry that IsDir(), construct path: filepath.Join(pluginDir, entry.Name(), "plugin.yaml")
3. Check if plugin.yaml exists with os.Stat; skip if not found
4. Call LoadPluginMetadata(manifestPath)
5. On error: log.Printf warning with plugin name and error, continue (do NOT fail the whole discovery)
6. On success: append to results slice
7. Return all successfully loaded plugins

Import "log", "os", "path/filepath".

**registry.go:**

Create `Registry` struct with:
- plugins map[string]*PluginMetadata (unexported field, keyed by plugin name)

Create `NewRegistry() *Registry` that initializes the map.

Methods on *Registry:
- `Register(meta *PluginMetadata) error` -- adds to map, returns error if name already registered (duplicate detection)
- `Get(name string) (*PluginMetadata, bool)` -- returns plugin by name with ok boolean
- `List() []*PluginMetadata` -- returns all registered plugins as a slice (sorted by name for deterministic ordering, use sort.Slice)
- `Count() int` -- returns len(plugins)

Create convenience function `LoadRegistry(pluginDir string) (*Registry, error)`:
1. Call DiscoverPlugins(pluginDir)
2. Create NewRegistry()
3. For each discovered plugin, call registry.Register()
4. If Register returns duplicate error, log warning and skip
5. Return registry and nil error (empty registry is valid -- no plugins found is not an error)

Import "sort" for deterministic List() ordering.
  </action>
  <verify>
Run `go build ./internal/plugins/` to confirm all three files compile together. Run `go vet ./internal/plugins/` to check for issues.
  </verify>
  <done>
DiscoverPlugins scans a directory for plugin.yaml files, skipping invalid entries with warnings. Registry provides Get/List/Register/Count with duplicate detection. LoadRegistry combines discovery and registration into a single call.
  </done>
</task>

</tasks>

<verification>
```bash
# All files compile
go build ./internal/plugins/

# No vet issues
go vet ./internal/plugins/

# Package exports are correct
go doc ./internal/plugins/ | grep -E "(PluginMetadata|LoadPluginMetadata|DiscoverPlugins|Registry|NewRegistry|LoadRegistry)"
```
</verification>

<success_criteria>
- internal/plugins/ package exists with metadata.go, discovery.go, registry.go
- PluginMetadata struct has all required fields with yaml struct tags
- LoadPluginMetadata uses KnownFields(true) for strict YAML validation
- DiscoverPlugins scans directories and handles errors gracefully
- Registry provides thread-safe plugin lookup by name
- LoadRegistry combines discovery + registration in one call
- All files compile and pass go vet
</success_criteria>

<output>
After completion, create `.planning/phases/08-plugin-framework-foundation/08-01-SUMMARY.md`
</output>
