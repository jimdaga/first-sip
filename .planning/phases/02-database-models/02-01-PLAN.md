---
phase: 02-database-models
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - env.local
  - internal/config/config.go
  - internal/database/db.go
  - internal/database/migrations.go
  - internal/crypto/crypto.go
  - migrations/000001_create_users.up.sql
  - migrations/000001_create_users.down.sql
  - migrations/000002_create_auth_identities.up.sql
  - migrations/000002_create_auth_identities.down.sql
  - migrations/000003_create_briefings.up.sql
  - migrations/000003_create_briefings.down.sql
  - go.mod
autonomous: true

must_haves:
  truths:
    - "Developer can start local Postgres with one command (docker compose up -d)"
    - "Application connects to Postgres using DSN from environment variables"
    - "SQL migrations run automatically on application start and create all tables"
    - "OAuth tokens can be encrypted and decrypted using AES-256-GCM"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Local Postgres container with health check"
      contains: "postgres:16-alpine"
    - path: "internal/database/db.go"
      provides: "GORM database connection with connection pooling"
      contains: "gorm.Open"
    - path: "internal/database/migrations.go"
      provides: "Embedded migration runner"
      contains: "go:embed"
    - path: "internal/crypto/crypto.go"
      provides: "AES-256-GCM encrypt/decrypt functions"
      contains: "cipher.NewGCM"
    - path: "internal/config/config.go"
      provides: "Database and encryption configuration"
      contains: "DatabaseURL"
    - path: "env.local"
      provides: "Local development environment variables"
      contains: "DATABASE_URL"
    - path: "migrations/000001_create_users.up.sql"
      provides: "Users table schema"
      contains: "CREATE TABLE users"
    - path: "migrations/000002_create_auth_identities.up.sql"
      provides: "Auth identities table schema"
      contains: "CREATE TABLE auth_identities"
    - path: "migrations/000003_create_briefings.up.sql"
      provides: "Briefings table schema"
      contains: "CREATE TABLE briefings"
  key_links:
    - from: "internal/database/db.go"
      to: "internal/config/config.go"
      via: "DSN from config"
      pattern: "cfg\\.DatabaseURL"
    - from: "internal/database/migrations.go"
      to: "migrations/*.sql"
      via: "go:embed directive"
      pattern: "go:embed migrations"
    - from: "internal/crypto/crypto.go"
      to: "env.local"
      via: "ENCRYPTION_KEY environment variable"
      pattern: "ENCRYPTION_KEY"
---

<objective>
Set up the database infrastructure foundation: Docker Compose for local Postgres, GORM connection with pooling, versioned SQL migrations via golang-migrate, and AES-256-GCM encryption helper for OAuth tokens.

Purpose: Establish the persistent storage layer that Phase 2 models and all subsequent phases depend on. Without this foundation, no data persists beyond sessions.
Output: Working Postgres container, database connection module, migration runner with all table schemas, encryption utility, and local development environment file.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-models/02-RESEARCH.md
@.planning/phases/01-authentication/01-01-SUMMARY.md
@internal/config/config.go
@cmd/server/main.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Docker Compose, database connection, and config updates</name>
  <files>
    docker-compose.yml
    env.local
    internal/config/config.go
    internal/database/db.go
    go.mod
  </files>
  <action>
    **1. Create `docker-compose.yml`** at project root:
    - Service: `postgres` using `postgres:16-alpine` image
    - Container name: `first-sip-db`
    - Environment: POSTGRES_DB=first_sip, POSTGRES_USER=first_sip, POSTGRES_PASSWORD=local_dev_password, POSTGRES_INITDB_ARGS="-E UTF8 --locale=en_US.utf8"
    - Ports: 5432:5432
    - Volume: `postgres_data:/var/lib/postgresql/data` (named volume for persistence)
    - Health check: `pg_isready -U first_sip -d first_sip` with interval=10s, timeout=5s, retries=5
    - restart: unless-stopped

    **2. Create `env.local`** at project root (for `source env.local` pattern):
    ```
    export DATABASE_URL="postgres://first_sip:local_dev_password@localhost:5432/first_sip?sslmode=disable"
    export ENCRYPTION_KEY="<base64-encoded 32-byte key>"
    ```
    Generate a real 32-byte key encoded in base64 for the default. Include comments explaining each variable.
    Also include existing env vars from Phase 1 (GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_CALLBACK_URL, SESSION_SECRET) with placeholder values and comments.

    **3. Update `internal/config/config.go`**:
    - Add `DatabaseURL string` field to Config struct
    - Add `EncryptionKey string` field to Config struct
    - Load DATABASE_URL from env (required, no default — log.Fatal if empty in production, warning in dev)
    - Load ENCRYPTION_KEY from env (required, no default — log.Fatal if empty in production, warning in dev)
    - Keep all existing fields and behavior intact

    **4. Create `internal/database/db.go`**:
    - Package: `database`
    - Function: `Init(databaseURL string) (*gorm.DB, error)` — opens GORM connection with postgres driver
    - Configure connection pooling: MaxOpenConns=20, MaxIdleConns=10, ConnMaxLifetime=5*time.Minute
    - Set TimeZone=UTC in DSN (append to URL if not present)
    - Return configured *gorm.DB instance
    - Function: `Close(db *gorm.DB) error` — gets underlying sql.DB and closes it (for graceful shutdown)

    **5. Add Go dependencies:**
    ```bash
    go get -u gorm.io/gorm gorm.io/driver/postgres
    ```

    Do NOT wire database into main.go yet — that happens in Plan 02-02.
  </action>
  <verify>
    - `docker compose up -d` starts Postgres container
    - `docker compose ps` shows healthy status
    - `go build ./...` compiles with new database package
    - `go vet ./...` reports no issues
    - env.local file exists with all required variables
    - `docker compose down` stops cleanly
  </verify>
  <done>
    Docker Compose starts Postgres locally, database package compiles with GORM connection and pooling, config loads DATABASE_URL and ENCRYPTION_KEY from environment, env.local provides all local dev variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SQL migration files and embedded migration runner</name>
  <files>
    migrations/000001_create_users.up.sql
    migrations/000001_create_users.down.sql
    migrations/000002_create_auth_identities.up.sql
    migrations/000002_create_auth_identities.down.sql
    migrations/000003_create_briefings.up.sql
    migrations/000003_create_briefings.down.sql
    internal/database/migrations.go
    go.mod
  </files>
  <action>
    **1. Create `migrations/000001_create_users.up.sql`:**
    ```sql
    CREATE TABLE users (
        id BIGSERIAL PRIMARY KEY,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        deleted_at TIMESTAMPTZ,
        email VARCHAR(255) NOT NULL,
        name VARCHAR(255) NOT NULL DEFAULT '',
        timezone VARCHAR(50) NOT NULL DEFAULT 'UTC',
        preferred_briefing_time VARCHAR(5) NOT NULL DEFAULT '06:00',
        role VARCHAR(20) NOT NULL DEFAULT 'user',
        last_login_at TIMESTAMPTZ,
        last_briefing_at TIMESTAMPTZ
    );

    CREATE INDEX idx_users_deleted_at ON users(deleted_at);
    CREATE UNIQUE INDEX idx_users_email ON users(email) WHERE deleted_at IS NULL;
    ```
    Note: Partial unique index on email WHERE deleted_at IS NULL allows soft-deleted users to have same email re-registered. Per locked decision: soft delete via GORM deleted_at.

    **2. Create `migrations/000001_create_users.down.sql`:**
    ```sql
    DROP TABLE IF EXISTS users;
    ```

    **3. Create `migrations/000002_create_auth_identities.up.sql`:**
    ```sql
    CREATE TABLE auth_identities (
        id BIGSERIAL PRIMARY KEY,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        deleted_at TIMESTAMPTZ,
        user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        provider VARCHAR(50) NOT NULL,
        provider_user_id VARCHAR(255) NOT NULL,
        access_token TEXT,
        refresh_token TEXT,
        token_expiry TIMESTAMPTZ
    );

    CREATE INDEX idx_auth_identities_deleted_at ON auth_identities(deleted_at);
    CREATE INDEX idx_auth_identities_user_id ON auth_identities(user_id);
    CREATE UNIQUE INDEX idx_auth_identities_provider_user ON auth_identities(provider, provider_user_id) WHERE deleted_at IS NULL;
    ```
    Per locked decision: separate auth_identities table, provider + provider_user_id for identification, stores access_token and refresh_token (encrypted via GORM hooks in Plan 02-02), token_expiry for tracking.

    **4. Create `migrations/000002_create_auth_identities.down.sql`:**
    ```sql
    DROP TABLE IF EXISTS auth_identities;
    ```

    **5. Create `migrations/000003_create_briefings.up.sql`:**
    ```sql
    CREATE TABLE briefings (
        id BIGSERIAL PRIMARY KEY,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        deleted_at TIMESTAMPTZ,
        user_id BIGINT NOT NULL REFERENCES users(id) ON DELETE CASCADE,
        content JSONB,
        status VARCHAR(20) NOT NULL DEFAULT 'pending',
        error_message TEXT,
        read_at TIMESTAMPTZ
    );

    CREATE INDEX idx_briefings_deleted_at ON briefings(deleted_at);
    CREATE INDEX idx_briefings_user_id ON briefings(user_id);
    CREATE INDEX idx_briefings_status ON briefings(status);
    CREATE INDEX idx_briefings_user_status ON briefings(user_id, status);
    ```
    Per locked decision: single JSON content field (JSONB), status lifecycle (pending/processing/completed/failed), error_message for failures, read_at for read tracking.

    **6. Create `migrations/000003_create_briefings.down.sql`:**
    ```sql
    DROP TABLE IF EXISTS briefings;
    ```

    **7. Create `internal/database/migrations.go`:**
    - Package: `database`
    - Use `//go:embed migrations/*.sql` directive to embed all migration files (the embed directive must reference from the package's own directory, so migrations/ dir must be INSIDE internal/database/ OR use a relative path — since migrations/ is at project root, use a different approach)
    - **IMPORTANT:** Go's embed directive only works with paths relative to the source file. Since migrations/ is at project root and this file is in internal/database/, we need to embed from the binary entry point instead. Create the embed FS in the database package but accept it as a parameter:
      - Function: `RunMigrations(dbURL string, migrationsFS embed.FS, migrationsDir string) error`
      - Uses iofs.New to create source from embedded FS
      - Creates migrate instance with Postgres driver
      - Runs m.Up(), handling migrate.ErrNoChange as success
      - Returns descriptive errors with fmt.Errorf wrapping

    Actually, the cleaner pattern: Put the `//go:embed` directive in `cmd/server/main.go` (where the migrations/ dir is accessible relative to root) and pass the FS to the database package. OR symlink. The simplest approach for this project: move migration SQL files under `internal/database/migrations/` so the embed works naturally from the database package.

    **Decision: Place migration files at `internal/database/migrations/`** so the go:embed directive in migrations.go can reference them directly. This is Claude's discretion per CONTEXT.md. Update all file paths accordingly.

    Revised structure:
    - `internal/database/migrations/000001_create_users.up.sql`
    - `internal/database/migrations/000001_create_users.down.sql`
    - etc.
    - `internal/database/migrations.go` with `//go:embed migrations/*.sql`

    The migrations.go function:
    ```go
    func RunMigrations(dbURL string) error
    ```
    - Creates iofs source from embedded migrationsFS
    - Creates migrate instance
    - Runs Up(), ErrNoChange is not an error
    - Logs migration success

    **8. Add Go dependencies:**
    ```bash
    go get -u github.com/golang-migrate/migrate/v4
    go get -u github.com/golang-migrate/migrate/v4/database/postgres
    go get -u github.com/golang-migrate/migrate/v4/source/iofs
    ```
  </action>
  <verify>
    - All 6 migration SQL files exist under internal/database/migrations/
    - `go build ./...` compiles with migration runner
    - `go vet ./...` reports no issues
    - Start Postgres (`docker compose up -d`), then run migrations programmatically via a quick test or temporary main:
      ```bash
      source env.local && go run cmd/server/main.go
      ```
      (This will fail until main.go is wired, but compilation verifying embed works is sufficient for this task)
    - Verify SQL syntax by checking files contain valid PostgreSQL DDL
  </verify>
  <done>
    Six versioned migration files (3 up + 3 down) define users, auth_identities, and briefings tables with proper indexes, foreign keys, and soft-delete support. Embedded migration runner compiles and is ready to be called from main.go.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create AES-256-GCM encryption helper package</name>
  <files>
    internal/crypto/crypto.go
  </files>
  <action>
    Create `internal/crypto/crypto.go`:
    - Package: `crypto`
    - Use Go standard library only: crypto/aes, crypto/cipher, crypto/rand, encoding/base64, errors, io, os

    **Functions:**
    1. `Init()` — called once at startup. Reads ENCRYPTION_KEY from environment variable, base64-decodes it, validates it is exactly 32 bytes (AES-256). Stores in package-level variable. Does NOT use init() — explicit initialization allows better error handling and testing.

    2. `InitWithKey(key string) error` — accepts a base64-encoded key string, validates and stores. Used by Init() and useful for testing.

    3. `Encrypt(plaintext string) (string, error)` — returns empty string for empty input (no-op). Creates AES cipher, creates GCM, generates random nonce via crypto/rand, seals plaintext with nonce prepended, returns base64-encoded result.

    4. `Decrypt(ciphertext string) (string, error)` — returns empty string for empty input (no-op). Base64-decodes, creates AES cipher, creates GCM, extracts nonce from beginning, opens ciphertext, returns plaintext string.

    **Critical details per research:**
    - Nonce MUST be generated via crypto/rand.Reader for every encryption (never reuse)
    - Nonce is prepended to ciphertext: `gcm.Seal(nonce, nonce, plaintext, nil)`
    - On decrypt: split first gcm.NonceSize() bytes as nonce, rest as ciphertext
    - Base64 encode/decode for storage as text in Postgres
    - Return descriptive errors wrapped with fmt.Errorf

    Per locked decision: AES-256-GCM for OAuth tokens only. Encryption key from env variable. No key rotation mechanism needed for Phase 2.
  </action>
  <verify>
    - `go build ./...` compiles successfully
    - `go vet ./...` reports no issues
    - Package has no external dependencies (stdlib only)
    - Encrypt("") returns "" (no-op for empty strings)
    - Encrypt then Decrypt round-trips correctly (verify mentally from code review; unit tests deferred to future TDD plan if needed)
  </verify>
  <done>
    Encryption package provides Encrypt/Decrypt functions using AES-256-GCM with random nonces, base64 encoding, and explicit initialization from environment variable. Ready to be used by GORM hooks in Plan 02-02.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `docker compose up -d` starts Postgres, `docker compose ps` shows healthy
2. `go build ./...` compiles entire project including new packages
3. `go vet ./...` reports no issues
4. `source env.local` loads all environment variables
5. Migration SQL files contain valid DDL for users, auth_identities, briefings tables
6. internal/database/, internal/crypto/ packages exist and compile
7. Config loads DATABASE_URL and ENCRYPTION_KEY from environment
</verification>

<success_criteria>
- Local Postgres starts with `docker compose up -d` and is accessible on port 5432
- Database connection package initializes GORM with Postgres driver and connection pooling
- Six migration files (3 up + 3 down) define complete schema for users, auth_identities, briefings
- Embedded migration runner compiles with go:embed directive
- AES-256-GCM encryption helper encrypts and decrypts strings using env-configured key
- Config struct includes DatabaseURL and EncryptionKey fields loaded from environment
- env.local provides all local development environment variables
- `go build ./...` passes with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-models/02-01-SUMMARY.md`
</output>
