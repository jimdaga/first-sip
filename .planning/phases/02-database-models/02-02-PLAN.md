---
phase: 02-database-models
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/models/user.go
  - internal/models/auth_identity.go
  - internal/models/briefing.go
  - internal/database/seed.go
  - cmd/server/main.go
  - Dockerfile
  - Makefile
autonomous: false

must_haves:
  truths:
    - "User records persist in Postgres with all required fields (email, name, timezone, role, activity timestamps)"
    - "AuthIdentity stores encrypted OAuth tokens that decrypt correctly on read"
    - "Briefing records support the full status lifecycle (pending/processing/completed/failed)"
    - "Database migrations run automatically when the application starts"
    - "Seed data creates a test user and sample briefing for local development"
  artifacts:
    - path: "internal/models/user.go"
      provides: "User GORM model with soft delete"
      contains: "gorm.Model"
    - path: "internal/models/auth_identity.go"
      provides: "AuthIdentity GORM model with encryption hooks"
      contains: "BeforeSave"
    - path: "internal/models/briefing.go"
      provides: "Briefing GORM model with JSONB content"
      contains: "datatypes.JSON"
    - path: "internal/database/seed.go"
      provides: "Development seed data"
      contains: "SeedDevData"
    - path: "cmd/server/main.go"
      provides: "Database initialization wired into application startup"
      contains: "database.Init"
  key_links:
    - from: "internal/models/auth_identity.go"
      to: "internal/crypto/crypto.go"
      via: "GORM BeforeSave/AfterFind hooks"
      pattern: "crypto\\.Encrypt|crypto\\.Decrypt"
    - from: "cmd/server/main.go"
      to: "internal/database/db.go"
      via: "database.Init call"
      pattern: "database\\.Init"
    - from: "cmd/server/main.go"
      to: "internal/database/migrations.go"
      via: "database.RunMigrations call"
      pattern: "database\\.RunMigrations"
    - from: "internal/models/briefing.go"
      to: "internal/models/user.go"
      via: "UserID foreign key"
      pattern: "UserID.*uint"
    - from: "internal/models/auth_identity.go"
      to: "internal/models/user.go"
      via: "UserID foreign key"
      pattern: "UserID.*uint"
---

<objective>
Create GORM model structs for User, AuthIdentity, and Briefing, implement encryption hooks on AuthIdentity, add development seed data, and wire database initialization into the application startup sequence.

Purpose: Complete the persistent storage layer by defining the data models that all subsequent phases depend on (briefing generation, display, history). This plan transforms the infrastructure from Plan 02-01 into a working, seeded database that the application uses on every startup.
Output: Three GORM models, encryption hooks, seed data, fully wired main.go with database init + migration + seed on startup.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-database-models/02-RESEARCH.md
@.planning/phases/02-database-models/02-01-SUMMARY.md
@internal/crypto/crypto.go
@internal/database/db.go
@internal/database/migrations.go
@internal/config/config.go
@cmd/server/main.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GORM models with encryption hooks</name>
  <files>
    internal/models/user.go
    internal/models/auth_identity.go
    internal/models/briefing.go
    go.mod
  </files>
  <action>
    **1. Create `internal/models/user.go`:**
    - Package: `models`
    - Struct: `User` embedding `gorm.Model` (provides ID, CreatedAt, UpdatedAt, DeletedAt)
    - Fields per locked decision:
      - Email string `gorm:"uniqueIndex;not null"` (partial unique index handled in migration, this tag for GORM awareness)
      - Name string `gorm:"not null;default:''"`
      - Timezone string `gorm:"not null;default:'UTC'"` (smart default, browser detection deferred to UI layer)
      - PreferredBriefingTime string `gorm:"not null;default:'06:00'"` (6 AM default per decision)
      - Role string `gorm:"not null;default:'user'"` (enum: 'user' or 'admin')
      - LastLoginAt *time.Time
      - LastBriefingAt *time.Time
    - Associations:
      - AuthIdentities []AuthIdentity `gorm:"constraint:OnDelete:CASCADE;"`
      - Briefings []Briefing `gorm:"constraint:OnDelete:CASCADE;"`
    - Per locked decision: soft delete via gorm.Model's DeletedAt, all timestamps UTC

    **2. Create `internal/models/auth_identity.go`:**
    - Package: `models`
    - Struct: `AuthIdentity` embedding `gorm.Model`
    - Fields per locked decision:
      - UserID uint `gorm:"not null;index"`
      - User User `gorm:"constraint:OnDelete:CASCADE;"`
      - Provider string `gorm:"not null"` (e.g., "google")
      - ProviderUserID string `gorm:"not null"`
      - AccessToken string `gorm:"type:text"` (stored encrypted)
      - RefreshToken string `gorm:"type:text"` (stored encrypted)
      - TokenExpiry *time.Time
    - Implement `BeforeSave(tx *gorm.DB) error` hook:
      - If AccessToken is not empty, encrypt it via crypto.Encrypt()
      - If RefreshToken is not empty, encrypt it via crypto.Encrypt()
      - Handle errors: return error to abort save
      - IMPORTANT: Always encrypt on save (not just when changed) because GORM's Statement.Changed() is unreliable for Create operations. To prevent double-encryption, check if the value is already base64-encoded ciphertext by attempting a decrypt first — if it succeeds, skip encryption. Alternatively, use a simpler approach: track plaintext state with an unexported field or always encrypt (since Seal produces different output each time due to random nonce, this is safe).
      - **Simplest correct approach:** Always encrypt non-empty tokens on save. AfterFind always decrypts. This means every Save re-encrypts with a fresh nonce (which is correct and safe for GCM).
    - Implement `AfterFind(tx *gorm.DB) error` hook:
      - If AccessToken is not empty, decrypt via crypto.Decrypt()
      - If RefreshToken is not empty, decrypt via crypto.Decrypt()
      - Handle errors: return error (prevents loading corrupted data)
    - Import `github.com/jimdaga/first-sip/internal/crypto`

    **3. Create `internal/models/briefing.go`:**
    - Package: `models`
    - Struct: `Briefing` embedding `gorm.Model`
    - Fields per locked decision:
      - UserID uint `gorm:"not null;index"`
      - User User `gorm:"constraint:OnDelete:CASCADE;"`
      - Content datatypes.JSON `gorm:"type:jsonb"` (single JSON field for all sections)
      - Status string `gorm:"not null;default:'pending';index"` (pending/processing/completed/failed)
      - ErrorMessage string `gorm:"column:error_message;type:text"` (maps to error_message column in migration)
      - ReadAt *time.Time
    - Add status constants:
      ```go
      const (
          BriefingStatusPending    = "pending"
          BriefingStatusProcessing = "processing"
          BriefingStatusCompleted  = "completed"
          BriefingStatusFailed     = "failed"
      )
      ```
    - Import `gorm.io/datatypes` for JSON type

    **4. Add dependency:**
    ```bash
    go get -u gorm.io/datatypes
    ```
  </action>
  <verify>
    - `go build ./...` compiles all model packages
    - `go vet ./...` reports no issues
    - User model has all fields from locked decisions (email, name, timezone, preferred_briefing_time, role, last_login_at, last_briefing_at)
    - AuthIdentity has BeforeSave and AfterFind hooks importing crypto package
    - Briefing has status constants and JSONB content field
    - All models embed gorm.Model for soft delete support
  </verify>
  <done>
    Three GORM models defined: User (with preferences, activity tracking, soft delete), AuthIdentity (with encrypted token hooks), Briefing (with JSONB content and status lifecycle). Models match the SQL migrations from Plan 02-01.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create seed data, wire database into main.go, update Dockerfile</name>
  <files>
    internal/database/seed.go
    cmd/server/main.go
    Dockerfile
    Makefile
  </files>
  <action>
    **1. Create `internal/database/seed.go`:**
    - Package: `database`
    - Function: `SeedDevData(db *gorm.DB) error`
    - Only runs if ENV != "production" (check via parameter or environment variable)
    - Check if seed data already exists (idempotent: skip if test user email already present)
    - Create test user:
      ```go
      user := models.User{
          Email:    "dev@firstsip.local",
          Name:     "Dev User",
          Timezone: "America/Chicago",
          PreferredBriefingTime: "07:00",
          Role:     "user",
      }
      ```
    - Create sample AuthIdentity for the test user:
      ```go
      identity := models.AuthIdentity{
          UserID:         user.ID,
          Provider:       "google",
          ProviderUserID: "dev-google-id-12345",
          AccessToken:    "dev-access-token-placeholder",
          RefreshToken:   "dev-refresh-token-placeholder",
      }
      ```
      (These tokens will be encrypted by the BeforeSave hook automatically)
    - Create sample completed briefing:
      ```go
      briefing := models.Briefing{
          UserID:  user.ID,
          Status:  models.BriefingStatusCompleted,
          Content: datatypes.JSON([]byte(`{
              "news": [
                  {"title": "Go 1.23 Released", "summary": "Latest Go release includes improved standard library.", "source": "go.dev"},
                  {"title": "Tech Industry Update", "summary": "Major developments in AI and cloud computing.", "source": "techcrunch.com"}
              ],
              "weather": {
                  "location": "Chicago, IL",
                  "temperature": "72F",
                  "condition": "Partly Cloudy",
                  "forecast": "Clear skies expected through the week."
              },
              "work": [
                  {"title": "Sprint Review", "summary": "Team demo at 2 PM today.", "source": "calendar"},
                  {"title": "PR Review Pending", "summary": "3 pull requests awaiting review.", "source": "github"}
              ]
          }`)),
      }
      ```
    - Create sample pending briefing (to show status lifecycle):
      ```go
      pendingBriefing := models.Briefing{
          UserID: user.ID,
          Status: models.BriefingStatusPending,
      }
      ```
    - Log what was seeded: "Seeded dev data: 1 user, 1 auth identity, 2 briefings"
    - Import models package

    **2. Update `cmd/server/main.go`:**
    Add database initialization AFTER config load, BEFORE route setup:

    ```go
    // Initialize encryption (must be before any model operations)
    crypto.Init()

    // Initialize database connection
    db, err := database.Init(cfg.DatabaseURL)
    if err != nil {
        log.Fatalf("Failed to connect to database: %v", err)
    }
    defer database.Close(db)

    // Run migrations
    if err := database.RunMigrations(cfg.DatabaseURL); err != nil {
        log.Fatalf("Failed to run migrations: %v", err)
    }
    log.Println("Database migrations completed successfully")

    // Seed development data
    if cfg.Env != "production" {
        if err := database.SeedDevData(db); err != nil {
            log.Printf("Warning: seed data failed: %v", err)
        }
    }
    ```

    Add imports for database and crypto packages:
    - `"github.com/jimdaga/first-sip/internal/crypto"`
    - `"github.com/jimdaga/first-sip/internal/database"`

    Keep ALL existing route handlers and middleware intact. The db variable is not yet used by handlers (that will happen in Phase 3+ when handlers need to query data). For now, it just initializes and runs migrations.

    **3. Update `Dockerfile`:**
    The Dockerfile needs to copy the go.sum file (if present) and the migrations directory for the embed to work during build. Since migrations are under internal/database/migrations/ and already copied via `COPY internal/ ./internal/`, this should work. But ensure go.sum is copied:
    ```dockerfile
    COPY go.mod go.sum ./
    ```
    (Currently only copies go.mod — needs go.sum for reproducible builds with new dependencies)

    Also add the migrations/ embed directory is included. Since we COPY internal/ already, this is covered. Verify the COPY commands include everything needed.

    **4. Update `Makefile`:**
    Add a `db-up` and `db-down` target for convenience:
    ```makefile
    db-up:
    	docker compose up -d

    db-down:
    	docker compose down

    db-reset:
    	docker compose down -v && docker compose up -d
    ```

    Update the `dev` target to remind about database:
    ```makefile
    dev: templ-generate
    	@echo "Ensure Postgres is running: make db-up"
    	source env.local && go run cmd/server/main.go
    ```
    Note: The `source` command won't work in Make (different shell context). Instead, update dev target to check for DATABASE_URL and remind user to source env.local manually, OR use `env.local` as a Makefile include. Simplest approach: just add the db targets and keep `dev` as-is. User runs `source env.local && make dev`.
  </action>
  <verify>
    - `go build ./...` compiles entire application including new packages
    - `go vet ./...` reports no issues
    - Start Postgres: `docker compose up -d`
    - Source env: `source env.local`
    - Run application: `go run cmd/server/main.go`
    - Verify in logs: "Database migrations completed successfully" and seed data message
    - Verify tables exist: `docker exec first-sip-db psql -U first_sip -d first_sip -c '\dt'` shows users, auth_identities, briefings tables
    - Verify seed data: `docker exec first-sip-db psql -U first_sip -d first_sip -c 'SELECT email, name FROM users'` shows dev@firstsip.local
    - Verify encrypted tokens: `docker exec first-sip-db psql -U first_sip -d first_sip -c 'SELECT access_token FROM auth_identities'` shows base64-encoded ciphertext (not plaintext)
    - Existing routes still work: `/health` returns 200, `/login` renders login page
    - Stop and restart application — migrations report "no change" (idempotent), seed data skips (idempotent)
  </verify>
  <done>
    Seed data creates test user, auth identity, and sample briefings for local development. Application startup initializes database, runs migrations, and seeds data. Dockerfile builds correctly with all dependencies. Existing authentication routes continue working unchanged.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify database persistence and encryption</name>
  <files>cmd/server/main.go</files>
  <action>
    Human verification checkpoint. No code changes — verify the complete database layer works end-to-end.

    What was built: Complete database layer including Docker Compose Postgres, GORM models (User, AuthIdentity, Briefing), AES-256-GCM encrypted OAuth tokens, versioned SQL migrations via golang-migrate, and development seed data. Application now initializes database on startup, runs migrations, and seeds test data.
  </action>
  <verify>
    1. Start Postgres: `make db-up` (or `docker compose up -d`)
    2. Wait for healthy: `docker compose ps` (should show "healthy")
    3. Source environment: `source env.local`
    4. Start application: `make dev` (or `go run cmd/server/main.go`)
    5. Check logs for: "Database migrations completed successfully" and seed data message
    6. Verify tables: `docker exec first-sip-db psql -U first_sip -d first_sip -c '\dt'`
       Expected: users, auth_identities, briefings, schema_migrations tables
    7. Verify seed user: `docker exec first-sip-db psql -U first_sip -d first_sip -c "SELECT id, email, name, timezone, role FROM users"`
       Expected: dev@firstsip.local, Dev User, America/Chicago, user
    8. Verify encrypted tokens: `docker exec first-sip-db psql -U first_sip -d first_sip -c "SELECT access_token FROM auth_identities LIMIT 1"`
       Expected: Long base64 string (NOT plaintext "dev-access-token-placeholder")
    9. Verify briefings: `docker exec first-sip-db psql -U first_sip -d first_sip -c "SELECT id, status, content IS NOT NULL as has_content FROM briefings"`
       Expected: One completed (with content), one pending (no content)
    10. Visit http://localhost:8080/login — login page still renders correctly
    11. Visit http://localhost:8080/health — returns {"status":"ok"}
    12. Stop app (Ctrl+C), restart — logs should show "no change" for migrations and "already exists" for seed data (idempotent)
  </verify>
  <done>Type "approved" or describe issues found</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `docker compose up -d` starts Postgres, `docker compose ps` shows healthy
2. `go build ./...` compiles entire project
3. `go vet ./...` reports no issues
4. Application starts and connects to Postgres
5. Migrations create users, auth_identities, briefings tables automatically
6. Seed data populates test user, auth identity with encrypted tokens, and sample briefings
7. OAuth tokens stored encrypted in database (not plaintext)
8. Application restart is idempotent (migrations: no change, seed: skip)
9. All existing Phase 1 routes continue working (/health, /login, /dashboard, /logout)
</verification>

<success_criteria>
- User model persists with all preference fields, activity timestamps, role, and soft delete
- AuthIdentity stores OAuth tokens encrypted via AES-256-GCM (verified by inspecting DB directly)
- Briefing model supports pending/processing/completed/failed status and JSONB content
- Migrations run automatically on application start via golang-migrate
- Seed data creates test user and sample briefings for local development
- Application startup is idempotent (safe to restart without data loss or duplicate errors)
- All Phase 1 authentication routes continue working unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/02-database-models/02-02-SUMMARY.md`
</output>
