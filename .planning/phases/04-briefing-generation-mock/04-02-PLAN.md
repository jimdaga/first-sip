---
phase: 04-briefing-generation-mock
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/briefings/handlers.go
  - internal/briefings/templates.templ
  - internal/worker/worker.go
  - internal/templates/dashboard.templ
  - cmd/server/main.go
autonomous: false

must_haves:
  truths:
    - "User clicks Generate Daily Summary button on dashboard"
    - "Briefing status shows Pending immediately after click"
    - "Status updates to Completed automatically after worker finishes"
    - "Generated briefing displays mock content with news, weather, work sections"
    - "Failed generation shows Failed status with error message"
    - "HTMX polling stops when briefing reaches terminal state"
  artifacts:
    - path: "internal/briefings/handlers.go"
      provides: "POST /api/briefings and GET /api/briefings/:id/status endpoints"
      exports: ["CreateBriefingHandler", "GetBriefingStatusHandler"]
    - path: "internal/briefings/templates.templ"
      provides: "BriefingCard, BriefingStatus, BriefingContentView Templ components"
      contains: "hx-trigger"
    - path: "internal/worker/worker.go"
      provides: "Real briefing generation handler with webhook client and DB access"
      contains: "webhookClient.GenerateBriefing"
    - path: "internal/templates/dashboard.templ"
      provides: "Dashboard with generate button and briefing display area"
      contains: "hx-post"
    - path: "cmd/server/main.go"
      provides: "Route registration and dependency wiring"
      contains: "/api/briefings"
  key_links:
    - from: "internal/templates/dashboard.templ"
      to: "internal/briefings/handlers.go"
      via: "hx-post to /api/briefings"
      pattern: "hx-post.*api/briefings"
    - from: "internal/briefings/templates.templ"
      to: "internal/briefings/handlers.go"
      via: "hx-get polling for status"
      pattern: "hx-get.*api/briefings.*status"
    - from: "internal/briefings/handlers.go"
      to: "internal/worker/tasks.go"
      via: "EnqueueGenerateBriefing call"
      pattern: "worker\\.EnqueueGenerateBriefing"
    - from: "internal/worker/worker.go"
      to: "internal/webhook/client.go"
      via: "webhookClient.GenerateBriefing in task handler"
      pattern: "webhookClient\\.GenerateBriefing"
    - from: "internal/worker/worker.go"
      to: "internal/models/briefing.go"
      via: "GORM database updates for status transitions"
      pattern: "db\\.Model.*briefing.*Update"
---

<objective>
Implement the complete briefing generation flow: HTTP handlers, Templ UI components with HTMX polling, real worker task handler, and dashboard integration.

Purpose: This is the core of Phase 4 -- connecting the generate button to background processing to UI status updates. After this plan, a user can click Generate, watch the spinner, and see their mock briefing appear.

Output: Working end-to-end briefing generation with HTMX polling status updates, verified by human checkpoint.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-briefing-generation-mock/04-RESEARCH.md
@.planning/phases/04-briefing-generation-mock/04-01-SUMMARY.md
@internal/webhook/types.go
@internal/webhook/client.go
@internal/worker/worker.go
@internal/worker/tasks.go
@internal/models/briefing.go
@internal/config/config.go
@internal/auth/middleware.go
@internal/auth/handlers.go
@internal/templates/dashboard.templ
@internal/templates/layout.templ
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create briefing HTTP handlers and Templ components</name>
  <files>internal/briefings/handlers.go, internal/briefings/templates.templ</files>
  <action>
Create `internal/briefings/handlers.go` with two Gin handler factories:

**CreateBriefingHandler(db *gorm.DB) gin.HandlerFunc:**
- Get user_id from Gin context via `c.Get("user_id")`. IMPORTANT: The session stores the Google OAuth UserID as a string (from `goth.User.UserID`), NOT a uint. The middleware copies this to context. You need to look up the User record by querying: `db.Where("email = ?", userEmail).First(&user)` using the `user_email` context value (also set by auth middleware). Use `user.ID` (the GORM auto-increment uint) as the foreign key for the Briefing.
- Check if there is already a pending/processing briefing for this user: `db.Where("user_id = ? AND status IN ?", user.ID, []string{"pending", "processing"}).First(&existing)`. If found, return the existing briefing card (don't create a duplicate).
- Create `models.Briefing{UserID: user.ID, Status: models.BriefingStatusPending}` and save with `db.Create(&briefing)`.
- Call `worker.EnqueueGenerateBriefing(briefing.ID)`. If enqueue fails, update briefing to failed status with error message "Failed to enqueue generation task" and return error HTML.
- Return HTML fragment by rendering the `BriefingCard(briefing)` Templ component. Use the render pattern: `c.Header("Content-Type", "text/html")` then `component.Render(c.Request.Context(), c.Writer)`.

**GetBriefingStatusHandler(db *gorm.DB) gin.HandlerFunc:**
- Parse briefing ID from URL param: `c.Param("id")`.
- Query briefing: `db.First(&briefing, briefingID)`. Return 404 if not found.
- Render `BriefingCard(briefing)` Templ component as HTML fragment (use same render pattern). Note: return the full card, not just status -- this allows the content to appear when completed.

Create `internal/briefings/templates.templ` with these components:

**templ BriefingCard(briefing models.Briefing):**
- Outer div with `id="briefing-area"`.
- If status is "pending" or "processing": add `hx-get` pointing to `/api/briefings/{id}/status`, `hx-trigger="every 2s"`, `hx-swap="outerHTML"` on the outer div. Show DaisyUI loading spinner (`<span class="loading loading-spinner loading-md"></span>`) with text "Generating your briefing...".
- If status is "completed": render a DaisyUI card (`class="card bg-base-100 shadow-xl"`) containing a card-body with:
  - Title "Daily Briefing" with a success badge
  - Call `@BriefingContentView(briefing)` to render sections
- If status is "failed": render a DaisyUI alert (`class="alert alert-error"`) showing "Generation failed. Please try again." (user-friendly message, NOT the raw ErrorMessage). Include a retry button with `hx-post="/api/briefings"` `hx-target="#briefing-area"` `hx-swap="outerHTML"`.
- KEY PATTERN: The `hx-trigger="every 2s"` attribute MUST only appear on pending/processing states. Terminal states (completed/failed) MUST NOT have hx-trigger. This is how HTMX polling stops (per research pitfall 1).

**templ BriefingContentView(briefing models.Briefing):**
- Unmarshal `briefing.Content` (which is `datatypes.JSON`, i.e., raw JSON bytes) into a `webhook.BriefingContent` struct. Use `json.Unmarshal([]byte(briefing.Content), &content)`. If unmarshal fails, show "Unable to display briefing content" message.
- Render three sections in a `div class="space-y-4 mt-4"`:
  - **News section**: h4 "News", loop over `content.News` items rendering each as a bordered-left card with linked title and summary paragraph.
  - **Weather section**: h4 "Weather", show location, temperature (with degree symbol), and condition.
  - **Work section**: h4 "Today's Schedule", bulleted list of `content.Work.TodayEvents`. h5 "Tomorrow", bulleted list of `content.Work.TomorrowTasks`.

Import the webhook package for types: `"github.com/jimdaga/first-sip/internal/webhook"`. Import models: `"github.com/jimdaga/first-sip/internal/models"`. Import `"encoding/json"` and `"fmt"` for content unmarshaling and ID formatting.

Use `fmt.Sprint(briefing.ID)` for constructing URL paths in templ attributes (standard pattern from research).
  </action>
  <verify>
Run `templ generate` -- must succeed without errors.
Run `go build ./internal/briefings/...` -- must compile without errors.
Run `go vet ./internal/briefings/...` -- must pass.
  </verify>
  <done>
Two HTTP handlers exist: CreateBriefingHandler creates a pending briefing and enqueues worker task, GetBriefingStatusHandler returns current briefing state. Templ components render briefing card with HTMX polling that stops on terminal states.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement real worker handler, update dashboard, wire routes</name>
  <files>internal/worker/worker.go, internal/templates/dashboard.templ, cmd/server/main.go</files>
  <action>
**Refactor `internal/worker/worker.go`:**

Change `Run(cfg *config.Config)` signature to `Run(cfg *config.Config, db *gorm.DB, webhookClient *webhook.Client)`. This passes database and webhook dependencies into the worker.

Replace the placeholder `handleGenerateBriefing` function with a real implementation. Change its signature to `handleGenerateBriefing(logger *slog.Logger, db *gorm.DB, webhookClient *webhook.Client) func(context.Context, *asynq.Task) error`. The returned closure:

1. Unmarshal task payload to get `briefing_id`. On JSON error, wrap with `asynq.SkipRetry` (non-retryable): `return fmt.Errorf("invalid payload: %w", asynq.SkipRetry)`.
2. Fetch briefing from DB: `db.WithContext(ctx).First(&briefing, payload.BriefingID)`. If not found, wrap with `asynq.SkipRetry`. If other DB error, return as-is (retryable).
3. Call `webhookClient.GenerateBriefing(ctx, briefing.UserID)`.
4. On webhook error: update briefing to failed status with error message, return the error (retryable by Asynq).
5. On success: marshal `*content` to JSON bytes using `json.Marshal(content)`. Update briefing with: `status = completed`, `content = jsonBytes` (assign raw bytes to `briefing.Content`), `generated_at = time.Now()`, `error_message = ""`. Use `db.Model(&briefing).Updates(map[string]interface{}{...})`.
6. Log success with briefing_id.

Update the `mux.HandleFunc` registration to pass `db` and `webhookClient` to the handler: `mux.HandleFunc(TaskGenerateBriefing, handleGenerateBriefing(logger, db, webhookClient))`.

Add required imports: `"gorm.io/gorm"`, `"github.com/jimdaga/first-sip/internal/models"`, `"github.com/jimdaga/first-sip/internal/webhook"`, `"errors"` (for `errors.Is`), `"time"`.

**Update `internal/templates/dashboard.templ`:**

Change `DashboardPage` signature to accept an optional briefing: `DashboardPage(name string, email string, latestBriefing *models.Briefing)`.

Replace the placeholder card content. The new dashboard body should:
- Keep the existing navbar (First Sip title, user name, logout button).
- In the container area:
  - h2 "Welcome, {name}" (existing).
  - A "Generate Daily Summary" button: `<button class="btn btn-primary" hx-post="/api/briefings" hx-target="#briefing-area" hx-swap="outerHTML">Generate Daily Summary</button>`.
  - A `<div id="briefing-area">` section:
    - If `latestBriefing != nil`: render `@briefings.BriefingCard(*latestBriefing)` (import briefings package).
    - If `latestBriefing == nil`: show a subtle message "No briefings yet. Click Generate to create your first one."

Import the briefings package: `"github.com/jimdaga/first-sip/internal/briefings"` and models package.

**Update `cmd/server/main.go`:**

1. Create the webhook client after config load: `webhookClient := webhook.NewClient(cfg.N8NWebhookURL, cfg.N8NWebhookSecret, cfg.N8NStubMode)`.
2. Store the `db` variable at a scope accessible to both mode branches. Currently `db` is declared inside the `if cfg.DatabaseURL != ""` block. Move the `var db *gorm.DB` declaration to before that block, then assign inside: `db, err = database.Init(...)` (change `:=` to `=`).
3. Pass `db` and `webhookClient` to `worker.Run(cfg, db, webhookClient)` in BOTH the standalone worker branch AND the embedded worker goroutine.
4. Add the briefing API routes inside the `protected` group:
   ```
   protected.POST("/api/briefings", briefingsHandlers.CreateBriefingHandler(db))
   protected.GET("/api/briefings/:id/status", briefingsHandlers.GetBriefingStatusHandler(db))
   ```
   Import the briefings handlers package with an alias to avoid collision with the briefings templ package: `briefingsHandlers "github.com/jimdaga/first-sip/internal/briefings"`. Actually since handlers.go and templates.templ are in the same package (`briefings`), just import once: `"github.com/jimdaga/first-sip/internal/briefings"` and call `briefings.CreateBriefingHandler(db)`.
5. Update the dashboard handler to query the latest briefing for the user:
   - After getting user email from context, look up user: `var user models.User; db.Where("email = ?", emailStr).First(&user)`.
   - Query latest briefing: `var latestBriefing models.Briefing; result := db.Where("user_id = ?", user.ID).Order("created_at DESC").First(&latestBriefing)`.
   - If result.Error is nil, pass `&latestBriefing` to DashboardPage. If record not found, pass `nil`.
   - Update render call: `render(c, templates.DashboardPage(nameStr, emailStr, latestBriefingPtr))`.

Add imports: `"github.com/jimdaga/first-sip/internal/webhook"`, `"github.com/jimdaga/first-sip/internal/briefings"`.

After all code changes, run `templ generate` to regenerate Go code from .templ files, then verify `go build ./...` compiles.
  </action>
  <verify>
Run `templ generate` -- must succeed.
Run `go build ./...` -- must compile without errors.
Run `go vet ./...` -- must pass.
Run `make lint` -- must pass (or identify only pre-existing warnings).
  </verify>
  <done>
Worker replaces placeholder with real briefing generation using webhook client and DB. Dashboard shows generate button and latest briefing. Routes wired in main.go. Full project compiles and lints cleanly.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify end-to-end briefing generation flow</name>
  <what-built>
Complete briefing generation flow: dashboard with Generate button, HTMX polling for status, worker processing with mock webhook data, briefing content display with News/Weather/Work sections.
  </what-built>
  <how-to-verify>
1. Start the application: `make dev` (ensure Docker Compose services are running: `docker compose up -d`)
2. Open http://localhost:8080 in browser, log in with Google OAuth
3. On the dashboard, you should see "Welcome, [name]" and a "Generate Daily Summary" button
4. Click the "Generate Daily Summary" button
5. Verify: A loading spinner appears immediately with "Generating your briefing..." text
6. Wait 2-5 seconds. The status should automatically update to "Completed" (the mock webhook has a 2-second delay)
7. Verify: The briefing card now displays three sections:
   - **News**: Two mock news items with titles and summaries
   - **Weather**: San Francisco, 65 degrees, Partly Cloudy
   - **Work**: Today's events (3 items) and tomorrow's tasks (3 items)
8. Refresh the page (F5). Verify the completed briefing still appears (persisted in database)
9. Check Asynqmon at http://localhost:8081 -- should show the completed task in the "Completed" tab
10. (Optional) To test failure: temporarily break the webhook (e.g., set N8N_STUB_MODE=false with no webhook URL), click Generate, and verify a "Generation failed" error message appears with a retry button
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues you see</resume-signal>
</task>

</tasks>

<verification>
- POST /api/briefings creates a pending briefing record and enqueues an Asynq task
- GET /api/briefings/:id/status returns HTML fragment with current briefing state
- Worker processes briefing:generate task, calls webhook client, updates DB with content
- HTMX polling starts on pending state and stops on completed/failed state
- Dashboard shows latest briefing on page load
- Completed briefing displays News, Weather, Work sections with mock data
- Failed briefing shows user-friendly error with retry button
- All existing routes (/health, /login, /dashboard, /auth/*, /logout) still work
</verification>

<success_criteria>
User can click "Generate Daily Summary", see a loading spinner, watch it transition to "Completed" with mock briefing content (news, weather, work), and see it persist across page refresh. Failed generation shows error with retry option. HTMX polling stops on terminal states.
</success_criteria>

<output>
After completion, create `.planning/phases/04-briefing-generation-mock/04-02-SUMMARY.md`
</output>
