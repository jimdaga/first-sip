---
phase: 01-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/server/main.go
  - go.mod
  - internal/auth/goth.go
  - internal/auth/handlers.go
  - internal/auth/middleware.go
  - internal/config/config.go
autonomous: true
user_setup:
  - service: google-oauth
    why: "Google OAuth requires client credentials from Google Cloud Console"
    env_vars:
      - name: GOOGLE_CLIENT_ID
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
      - name: GOOGLE_CLIENT_SECRET
        source: "Google Cloud Console -> APIs & Services -> Credentials -> OAuth 2.0 Client IDs"
      - name: GOOGLE_CALLBACK_URL
        source: "Set to http://localhost:8080/auth/google/callback for local dev"
      - name: SESSION_SECRET
        source: "Generate with: openssl rand -hex 32"
    dashboard_config:
      - task: "Create OAuth 2.0 Client ID (Web application type)"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Create Credentials"
      - task: "Add http://localhost:8080/auth/google/callback as Authorized redirect URI"
        location: "Google Cloud Console -> APIs & Services -> Credentials -> Edit OAuth Client"

must_haves:
  truths:
    - "Gin router serves requests on :8080 replacing net/http mux"
    - "Goth Google provider is initialized with env-based credentials"
    - "Session middleware is registered globally before auth routes"
    - "OAuth login handler initiates Google OAuth flow"
    - "OAuth callback handler completes auth and stores user info in session"
    - "Logout handler clears session and redirects to login"
    - "Auth middleware redirects unauthenticated users, with HX-Redirect for HTMX requests"
  artifacts:
    - path: "cmd/server/main.go"
      provides: "Gin router with session middleware, Goth init, route registration"
      contains: "gin.Default"
    - path: "internal/auth/goth.go"
      provides: "Goth provider initialization"
      contains: "goth.UseProviders"
    - path: "internal/auth/handlers.go"
      provides: "Login, callback, and logout HTTP handlers"
      contains: "gothic.BeginAuthHandler"
    - path: "internal/auth/middleware.go"
      provides: "Auth-required middleware with HTMX support"
      contains: "HX-Redirect"
    - path: "internal/config/config.go"
      provides: "Centralized config loading from environment"
      contains: "os.Getenv"
    - path: "go.mod"
      provides: "All required dependencies"
      contains: "markbates/goth"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/auth/goth.go"
      via: "auth.InitProviders() call before route setup"
      pattern: "auth\\.InitProviders"
    - from: "cmd/server/main.go"
      to: "internal/auth/handlers.go"
      via: "route registration for /auth/google and /auth/google/callback"
      pattern: "auth\\.HandleLogin|auth\\.HandleCallback"
    - from: "internal/auth/handlers.go"
      to: "gin-contrib/sessions"
      via: "session.Set/Get in callback handler"
      pattern: "sessions\\.Default"
    - from: "internal/auth/middleware.go"
      to: "gin-contrib/sessions"
      via: "session.Get to check authentication"
      pattern: "session\\.Get"
---

<objective>
Set up Go authentication backend: replace net/http with Gin, configure Google OAuth via Goth, implement session middleware with cookie store, and create all auth handlers (login, callback, logout) plus route-protection middleware.

Purpose: Establishes the complete server-side authentication infrastructure that the UI layer (Plan 02) will connect to. After this plan, all auth logic exists and compiles -- it just needs templates wired to be usable.

Output: Gin-based server with working auth handlers, session management, and route protection middleware.
</objective>

<execution_context>
@/home/jim/.claude/get-shit-done/workflows/execute-plan.md
@/home/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-authentication/01-RESEARCH.md
@cmd/server/main.go
@go.mod
@internal/health/handler.go
@.planning/codebase/STACK.md
@.planning/codebase/CONVENTIONS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace net/http with Gin, install dependencies, configure sessions and Goth</name>
  <files>
    go.mod
    cmd/server/main.go
    internal/config/config.go
    internal/auth/goth.go
  </files>
  <action>
    1. Install all required dependencies:
       ```
       go get github.com/gin-gonic/gin
       go get github.com/gin-contrib/sessions
       go get github.com/gin-contrib/sessions/cookie
       go get github.com/markbates/goth@v1.82.0
       go get github.com/markbates/goth/gothic
       go get github.com/markbates/goth/providers/google
       ```

    2. Create `internal/config/config.go`:
       - Define a `Config` struct with fields: GoogleClientID, GoogleClientSecret, GoogleCallbackURL, SessionSecret, Env (dev/production), Port
       - Create `Load()` function that reads from environment variables with sensible defaults:
         - PORT defaults to "8080"
         - ENV defaults to "development"
         - SESSION_SECRET defaults to a hardcoded dev-only fallback (log warning if using default)
         - GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_CALLBACK_URL have no defaults (required for OAuth to work, but app should still start without them for build/test)
       - No external config libraries -- use os.Getenv directly

    3. Create `internal/auth/goth.go`:
       - Define `InitProviders(cfg *config.Config)` function
       - Call `goth.UseProviders()` with `google.New()` using config values
       - Request scopes: "email", "profile"
       - If GoogleClientID is empty, log a warning but don't panic (allows app to start for build verification)

    4. Rewrite `cmd/server/main.go`:
       - Replace `http.NewServeMux()` with `gin.Default()`
       - Load config via `config.Load()`
       - Set up cookie session store via `cookie.NewStore([]byte(cfg.SessionSecret))`
       - Configure session options: Path="/", MaxAge=86400*30 (30 days), HttpOnly=true, Secure=(cfg.Env=="production"), SameSite=http.SameSiteLaxMode (not Strict -- Strict breaks OAuth redirects from Google)
       - Register session middleware BEFORE any routes: `r.Use(sessions.Sessions("first_sip_session", store))`
       - Call `auth.InitProviders(cfg)` AFTER session middleware (Goth needs sessions available)
       - Keep health endpoint: `r.GET("/health", func(c *gin.Context) { c.JSON(200, gin.H{"status": "ok"}) })`
       - Add placeholder comments for auth routes and protected routes (wired in Task 2)
       - Start server with `r.Run(":" + cfg.Port)`

    IMPORTANT: Use SameSite=Lax, NOT Strict. Strict mode blocks cookies on cross-origin redirects, which breaks the Google OAuth callback redirect back to our app. Lax allows top-level navigation redirects while still preventing CSRF on POST requests.

    IMPORTANT: Use cookie session store (not Redis) for Phase 1. Redis backend will be added in Phase 3 when Redis infrastructure exists. Cookie store persists across browser refresh and restart via cookie MaxAge, satisfying AUTH-02.

    NOTE: The existing health handler at `internal/health/handler.go` uses net/http signature. Convert it inline in main.go as a simple Gin handler for now. The health package can be updated later when other handlers adopt Gin patterns.
  </action>
  <verify>
    Run `go build ./...` -- must compile with zero errors.
    Run `go vet ./...` -- must pass.
    Run `go run cmd/server/main.go &` then `curl http://localhost:8080/health` returns `{"status":"ok"}`.
    Kill the server process after verification.
  </verify>
  <done>
    Gin server starts on :8080, health endpoint returns JSON, session middleware is registered, Goth providers initialized (with warning if no Google credentials). All new files compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth handlers (login, callback, logout) and auth middleware</name>
  <files>
    internal/auth/handlers.go
    internal/auth/middleware.go
    cmd/server/main.go
  </files>
  <action>
    1. Create `internal/auth/handlers.go` with three Gin handler functions:

       `HandleLogin(c *gin.Context)`:
       - Set "provider" query parameter to "google" on the request URL (gothic requires this)
       - Call `gothic.BeginAuthHandler(c.Writer, c.Request)` to initiate OAuth flow
       - This redirects the user to Google's consent screen

       `HandleCallback(c *gin.Context)`:
       - Set "provider" query parameter to "google" on the request URL
       - Call `gothic.CompleteUserAuth(c.Writer, c.Request)` to get the authenticated user
       - On error: log the error, redirect to "/login" with a query param `?error=auth_failed`
       - On success:
         - Get session via `sessions.Default(c)`
         - Store in session: "user_id" (user.UserID), "user_email" (user.Email), "user_name" (user.Name), "user_avatar" (user.AvatarURL)
         - Call `session.Save()` -- check error return
         - Redirect to "/dashboard" with 302

       `HandleLogout(c *gin.Context)`:
       - Get session via `sessions.Default(c)`
       - Call `session.Clear()`
       - Call `session.Save()`
       - Redirect to "/login" with 302

       NOTE: We store user info directly in the session (not a database User model) for Phase 1. The User GORM model with database persistence comes in Phase 2. This avoids needing Postgres/GORM infrastructure in Phase 1.

    2. Create `internal/auth/middleware.go`:

       `RequireAuth() gin.HandlerFunc`:
       - Get session via `sessions.Default(c)`
       - Check `session.Get("user_id")` -- if nil, user is not authenticated
       - If NOT authenticated:
         - Check `c.GetHeader("HX-Request") == "true"` for HTMX requests
         - HTMX: Set header `HX-Redirect: /login`, abort with 401
         - Non-HTMX: Redirect to "/login" with 302, call c.Abort()
       - If authenticated:
         - Set `c.Set("user_id", userID)` for downstream handlers
         - Set `c.Set("user_email", session.Get("user_email"))` for downstream handlers
         - Set `c.Set("user_name", session.Get("user_name"))` for downstream handlers
         - Call `c.Next()`

    3. Update `cmd/server/main.go` to wire routes:

       Public routes (no middleware):
       - `GET /login` -- placeholder handler returning "Login page (coming in Plan 02)" text for now
       - `GET /auth/google` -- auth.HandleLogin
       - `GET /auth/google/callback` -- auth.HandleCallback

       Protected route group with `auth.RequireAuth()` middleware:
       - `GET /dashboard` -- placeholder handler returning "Dashboard (coming in Plan 02)" text for now
       - `GET /logout` -- auth.HandleLogout
       - `GET /` -- redirect to /dashboard

       The placeholder handlers are temporary -- Plan 02 replaces them with Templ templates.
  </action>
  <verify>
    Run `go build ./...` -- must compile with zero errors.
    Run `go vet ./...` -- must pass.
    Run `make lint` (or `golangci-lint run ./...`) -- must pass with no errors.
    Start server and verify:
    - `curl -v http://localhost:8080/login` returns 200 with placeholder text
    - `curl -v http://localhost:8080/dashboard` returns 302 redirect to /login (unauthenticated)
    - `curl -v http://localhost:8080/auth/google` returns 302 redirect to Google (if credentials configured) or error (if not)
    - `curl -v -H "HX-Request: true" http://localhost:8080/dashboard` returns 401 with HX-Redirect header
  </verify>
  <done>
    Auth handlers compile and register correctly. Unauthenticated requests to /dashboard redirect to /login (302 for normal, 401+HX-Redirect for HTMX). Login endpoint initiates OAuth flow. Logout endpoint clears session. All lint checks pass.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles all packages with zero errors
2. `go vet ./...` reports no issues
3. `golangci-lint run ./...` passes
4. Server starts on :8080 and /health returns {"status":"ok"}
5. /dashboard redirects unauthenticated users to /login
6. /auth/google initiates OAuth flow (or returns error if no credentials)
7. HTMX requests to protected routes get 401 + HX-Redirect header
</verification>

<success_criteria>
- Gin replaces net/http as the router framework
- Google OAuth flow is wired via Goth (login -> Google -> callback -> session -> dashboard)
- Cookie-based sessions persist user info across browser refresh (MaxAge 30 days)
- Auth middleware protects /dashboard route group
- HTMX-compatible auth redirects via HX-Redirect header
- All code compiles and passes linting
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication/01-01-SUMMARY.md`
</output>
