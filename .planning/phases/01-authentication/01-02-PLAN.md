---
phase: 01-authentication
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/templates/layout.templ
  - internal/templates/login.templ
  - internal/templates/dashboard.templ
  - cmd/server/main.go
  - Makefile
autonomous: false
must_haves:
  truths:
    - "User sees a login page with 'Login with Google' button at /login"
    - "User sees dashboard with their name and a logout link after login"
    - "User can click Logout and be returned to login page"
    - "Protected routes redirect unauthenticated users to login page"
    - "Session persists across browser refresh (user stays logged in)"
  artifacts:
    - path: "internal/templates/layout.templ"
      provides: "Shared HTML layout with HTMX and DaisyUI CDN links"
      contains: "htmx.org"
    - path: "internal/templates/login.templ"
      provides: "Login page with Google OAuth button"
      contains: "Login with Google"
    - path: "internal/templates/dashboard.templ"
      provides: "Dashboard page with user info and logout link"
      contains: "Logout"
    - path: "cmd/server/main.go"
      provides: "Route handlers rendering Templ components"
      contains: "templates.LoginPage"
    - path: "Makefile"
      provides: "Templ generate and build targets"
      contains: "templ generate"
  key_links:
    - from: "internal/templates/login.templ"
      to: "/auth/google"
      via: "anchor href on login button"
      pattern: "href.*auth/google"
    - from: "internal/templates/dashboard.templ"
      to: "/logout"
      via: "anchor href on logout link"
      pattern: "href.*logout"
    - from: "cmd/server/main.go"
      to: "internal/templates"
      via: "Templ component render in Gin handlers"
      pattern: "templates\\."
    - from: "internal/templates/layout.templ"
      to: "HTMX CDN"
      via: "script tag in head"
      pattern: "unpkg\\.com/htmx"
---

<objective>
Create Templ templates for login and dashboard pages with DaisyUI styling, wire them into Gin route handlers, and verify the complete authentication flow end-to-end.

Purpose: Transforms the auth backend (Plan 01) into a usable application. After this plan, a user can open the browser, see a login page, authenticate with Google, land on their dashboard, and log out -- the full Phase 1 experience.

Output: Working login page, dashboard page, Templ build pipeline, and verified end-to-end OAuth flow.
</objective>

<execution_context>
@/home/jim/.claude/get-shit-done/workflows/execute-plan.md
@/home/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-authentication/01-RESEARCH.md
@.planning/phases/01-authentication/01-01-SUMMARY.md
@cmd/server/main.go
@internal/auth/handlers.go
@internal/auth/middleware.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Templ CLI, create layout and page templates with DaisyUI</name>
  <files>
    internal/templates/layout.templ
    internal/templates/login.templ
    internal/templates/dashboard.templ
    Makefile
  </files>
  <action>
    1. Install the Templ CLI tool:
       ```
       go install github.com/a-h/templ/cmd/templ@latest
       ```
       Add templ as a Go dependency:
       ```
       go get github.com/a-h/templ
       ```

    2. Create `internal/templates/layout.templ`:
       - Define a `Layout(title string)` component that wraps child content
       - HTML5 doctype, lang="en"
       - Head section with:
         - Meta charset utf-8, viewport for mobile
         - Title from parameter
         - Tailwind CSS via CDN: `<script src="https://cdn.tailwindcss.com"></script>`
         - DaisyUI via CDN: `<link href="https://cdn.jsdelivr.net/npm/daisyui@4/dist/full.min.css" rel="stylesheet" type="text/css" />`
         - HTMX via CDN: `<script src="https://unpkg.com/htmx.org@2.0.0"></script>`
       - Body with `{ children... }` slot for page content
       - Use DaisyUI "light" theme: `<html data-theme="light">`

    3. Create `internal/templates/login.templ`:
       - Define `LoginPage()` component
       - Use Layout("Login - First Sip") as wrapper
       - Centered hero section (DaisyUI hero component):
         - App name "First Sip" as h1 (text-5xl font-bold)
         - Tagline: "Your daily briefing, personalized." as paragraph
         - "Login with Google" as a DaisyUI btn btn-primary linking to "/auth/google"
         - Use a simple coffee/sun icon or emoji-free text only
       - If there's an "error" query param, show a DaisyUI alert alert-error with message "Authentication failed. Please try again."
       - Minimal, clean design -- this is a personal tool, not a marketing page

    4. Create `internal/templates/dashboard.templ`:
       - Define `DashboardPage(name string, email string)` component accepting user info
       - Use Layout("Dashboard - First Sip") as wrapper
       - DaisyUI navbar at top:
         - "First Sip" brand text on left
         - User name display on right
         - "Logout" link (btn btn-ghost btn-sm) pointing to "/logout" on right
       - Main content area:
         - Welcome message: "Good morning, {name}" (or just "Welcome, {name}")
         - Placeholder card (DaisyUI card): "Your daily briefing will appear here." with a subtle note "Briefing generation coming in Phase 4"
       - This is a stub dashboard -- Phase 4/5 will add real briefing content

    5. Update `Makefile` to add Templ targets:
       - Add `templ-generate` target: `templ generate`
       - Update `build` target to depend on `templ-generate` (run templ generate before go build)
       - Add `dev` target that runs `templ generate && go run cmd/server/main.go`
       - Keep existing targets (test, lint, clean, etc.) intact

    6. Run `templ generate` to produce the `*_templ.go` files.
       Verify the generated files exist in `internal/templates/`.

    NOTE on CDN approach: Using Tailwind CSS CDN + DaisyUI CDN for Phase 1 simplicity. A proper Tailwind build pipeline can be added later if needed. The CDN approach is fine for a personal tool.
  </action>
  <verify>
    Run `templ generate` -- must succeed with no errors.
    Verify generated files exist: `ls internal/templates/*_templ.go` should show 3 files.
    Run `go build ./...` -- must compile (templates generate valid Go code).
  </verify>
  <done>
    Three Templ template files exist (layout, login, dashboard) with DaisyUI styling. Templ CLI generates Go code successfully. Makefile has templ-generate target integrated into build pipeline.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Templ templates into Gin routes, verify complete build</name>
  <files>
    cmd/server/main.go
  </files>
  <action>
    1. Update `cmd/server/main.go` to replace placeholder text handlers with Templ renderers:

       For the `/login` route handler:
       - Check for "error" query parameter from `c.Query("error")`
       - Render `templates.LoginPage()` using Templ's HTTP handler:
         `templates.LoginPage().Render(c.Request.Context(), c.Writer)` (set Content-Type to text/html first)
       - Or use the templ handler adapter: `templ.Handler(templates.LoginPage())` -- but since we need gin.Context, use the Render approach

       For the `/dashboard` route handler:
       - Extract user info from gin.Context: `c.GetString("user_name")`, `c.GetString("user_email")`
       - These were set by the RequireAuth middleware from session values
       - Render `templates.DashboardPage(name, email)` via `.Render(c.Request.Context(), c.Writer)`
       - Set Content-Type to "text/html" before rendering

       Helper pattern for rendering Templ in Gin:
       ```go
       func render(c *gin.Context, component templ.Component) {
           c.Header("Content-Type", "text/html")
           component.Render(c.Request.Context(), c.Writer)
       }
       ```
       Define this as a package-level helper in main.go (or a small internal/web/render.go if preferred).

    2. Update the `/` root route:
       - If user is authenticated (check session), redirect to /dashboard
       - If not authenticated, redirect to /login
       - This can be a simple handler outside the protected group that checks session

    3. Ensure import paths are correct:
       - `"github.com/jimdaga/first-sip/internal/templates"` for Templ components
       - `"github.com/a-h/templ"` for the templ package (if using templ.Component type)

    4. Run the full build pipeline:
       ```
       templ generate && go build ./...
       ```

    5. Run linting:
       ```
       golangci-lint run ./...
       ```
       Fix any issues. Common Templ gotcha: generated files may trigger linter warnings -- if so, add generated file patterns to `.golangci.yml` exclude or use `//nolint` directives on generated files sparingly.

    6. Verify the existing health endpoint still works after all changes.
  </action>
  <verify>
    Run `templ generate && go build ./...` -- must compile cleanly.
    Run `golangci-lint run ./...` -- must pass (or only have warnings on generated files).
    Start server: `go run cmd/server/main.go`
    - `curl http://localhost:8080/health` returns {"status":"ok"}
    - `curl http://localhost:8080/login` returns HTML containing "Login with Google"
    - `curl http://localhost:8080/dashboard` returns 302 redirect to /login
    - `curl -H "HX-Request: true" http://localhost:8080/dashboard` returns 401 with HX-Redirect header
    - `curl http://localhost:8080/` redirects to /login (unauthenticated)
  </verify>
  <done>
    All routes serve correct responses. Login page renders HTML with "Login with Google" button. Dashboard is protected and redirects unauthenticated users. Health endpoint still works. Full build pipeline (templ generate -> go build) succeeds. Linting passes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete OAuth flow in browser</name>
  <files>none</files>
  <action>
    This is a human verification checkpoint. Claude starts the server and prepares the environment, then the user verifies the OAuth flow in their browser.

    Claude should:
    1. Ensure all env vars are documented for the user
    2. Run `make dev` or `templ generate && go run cmd/server/main.go` to start the server
    3. Present the verification steps below to the user
  </action>
  <verify>
    User performs the following browser verification:

    Prerequisites: Ensure GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GOOGLE_CALLBACK_URL, and SESSION_SECRET environment variables are set (see user_setup in Plan 01).

    1. Start the server: `make dev` (or `templ generate && go run cmd/server/main.go`)
    2. Open browser to http://localhost:8080
       - Expected: Redirected to /login, see "First Sip" heading and "Login with Google" button
    3. Click "Login with Google"
       - Expected: Redirected to Google consent screen
    4. Complete Google sign-in
       - Expected: Redirected back to /dashboard, see "Welcome, [Your Name]" and logout link
    5. Refresh the page (F5 or Cmd+R)
       - Expected: Still on dashboard, still logged in (session persists)
    6. Close browser completely, reopen, navigate to http://localhost:8080
       - Expected: Still logged in (cookie persists across browser restart)
    7. Click "Logout"
       - Expected: Redirected to /login page
    8. Try to navigate directly to http://localhost:8080/dashboard
       - Expected: Redirected to /login (session cleared)
  </verify>
  <done>
    User confirms all 8 verification steps pass: login page renders, OAuth flow completes, session persists across refresh and restart, logout works, protected routes redirect unauthenticated users. Phase 1 authentication is complete.
  </done>
</task>

</tasks>

<verification>
1. `templ generate && go build ./...` compiles all packages
2. `golangci-lint run ./...` passes
3. Login page renders with "Login with Google" button at /login
4. Dashboard shows user name and logout link at /dashboard
5. Unauthenticated /dashboard access redirects to /login
6. HTMX requests to protected routes get HX-Redirect header
7. /health endpoint still returns {"status":"ok"}
8. Full OAuth flow works: login -> Google -> callback -> dashboard -> logout
9. Session persists across browser refresh and restart
</verification>

<success_criteria>
- Login page renders with DaisyUI styling and "Login with Google" button
- Dashboard page shows authenticated user's name and email
- Complete OAuth flow: login -> Google consent -> callback -> dashboard
- Logout clears session and returns to login page
- Session persists across browser refresh (AUTH-02)
- Protected routes redirect to login (success criteria #4)
- Templ build pipeline integrated into Makefile
- All code compiles and passes linting
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication/01-02-SUMMARY.md`
</output>
