---
phase: 03-background-job-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/worker/worker.go
  - internal/worker/tasks.go
  - internal/worker/logging.go
  - cmd/server/main.go
  - Makefile
autonomous: false

must_haves:
  truths:
    - "Asynq worker starts and connects to Redis when launched with --worker flag"
    - "Tasks enqueued via worker.EnqueueGenerateBriefing() appear in Redis queue"
    - "Worker processes tasks from the queue and logs execution"
    - "Failed tasks retry up to 3 times then archive to dead letter queue"
    - "In development mode, make dev starts both web server and embedded worker in one process"
    - "Worker logs are structured (slog) with configurable level and format"
  artifacts:
    - path: "internal/worker/worker.go"
      provides: "Asynq server initialization with error handler and mux"
      exports: ["Run"]
      min_lines: 50
    - path: "internal/worker/tasks.go"
      provides: "Asynq client singleton, task constants, enqueue helpers"
      exports: ["InitClient", "CloseClient", "EnqueueGenerateBriefing"]
      contains: "TaskGenerateBriefing"
    - path: "internal/worker/logging.go"
      provides: "slog-based logger factory for Asynq with level/format config"
      exports: ["NewLogger"]
      min_lines: 20
    - path: "cmd/server/main.go"
      provides: "Mode switching via --worker flag, embedded worker in dev"
      contains: "workerMode"
    - path: "Makefile"
      provides: "Updated dev target that starts embedded worker"
      contains: "worker"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/worker"
      via: "--worker flag branches to worker.Run()"
      pattern: "worker\\.Run"
    - from: "internal/worker/tasks.go"
      to: "internal/worker/worker.go"
      via: "TaskGenerateBriefing constant used in mux.HandleFunc registration"
      pattern: "TaskGenerateBriefing"
    - from: "internal/worker/worker.go"
      to: "internal/config"
      via: "Config.RedisURL parsed by asynq.ParseRedisURI"
      pattern: "ParseRedisURI.*RedisURL"
    - from: "cmd/server/main.go"
      to: "internal/worker/tasks.go"
      via: "InitClient called on startup, CloseClient deferred"
      pattern: "worker\\.InitClient"
---

<objective>
Create the Asynq worker package with server, client, task definitions, and structured logging. Wire mode-switching into main.go so the binary runs as web server (default) or worker (--worker flag), with an embedded worker in development mode.

Purpose: This is the core deliverable of Phase 3 -- the background job infrastructure that Phases 4-7 build on. After this plan, tasks can be enqueued from HTTP handlers and processed asynchronously.
Output: Working worker process, task enqueue helpers, structured logging, mode-switching binary, verified end-to-end task flow.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-background-job-infrastructure/03-RESEARCH.md
@.planning/phases/03-background-job-infrastructure/03-CONTEXT.md
@.planning/phases/03-background-job-infrastructure/03-01-SUMMARY.md
@cmd/server/main.go
@internal/config/config.go
@internal/models/briefing.go
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker package (worker.go, tasks.go, logging.go)</name>
  <files>internal/worker/worker.go, internal/worker/tasks.go, internal/worker/logging.go</files>
  <action>
Create three files in `internal/worker/`:

**internal/worker/logging.go:**
- Package `worker`
- Export `NewLogger(level, format string) *slog.Logger` function
- Parse level string ("debug"/"info"/"warn"/"error") into slog.Level (default: slog.LevelInfo)
- If format == "json", use slog.NewJSONHandler(os.Stdout, opts); otherwise slog.NewTextHandler(os.Stdout, opts)
- Return `slog.New(handler)`

**internal/worker/tasks.go:**
- Package `worker`
- Define task type constants:
  - `TaskGenerateBriefing = "briefing:generate"`
- Package-level `var client *asynq.Client` (unexported)
- Export `InitClient(redisURL string) error`:
  - Parse redisURL with `asynq.ParseRedisURI()`
  - Create `asynq.NewClient(opt)` and assign to package var
  - Return nil on success
- Export `CloseClient() error`:
  - If client != nil, call client.Close()
  - Return nil
- Export `EnqueueGenerateBriefing(briefingID uint) error`:
  - Marshal payload: `{"briefing_id": briefingID}` as JSON
  - Create task with `asynq.NewTask(TaskGenerateBriefing, payload, asynq.MaxRetry(3), asynq.Timeout(5*time.Minute), asynq.Retention(24*time.Hour))`
  - Enqueue with `client.Enqueue(task)`
  - Return error (or nil on success)
- Use `uint` for briefingID (matches gorm.Model ID type, not int64)
- Task timeout: 5 minutes per research recommendation (Claude's discretion)

**internal/worker/worker.go:**
- Package `worker`
- Import asynq, config, slog, context, encoding/json, fmt
- Export `Run(cfg *config.Config) error`:
  - Parse cfg.RedisURL with `asynq.ParseRedisURI()`
  - Create logger via `NewLogger(cfg.LogLevel, cfg.LogFormat)`
  - Create `asynq.NewServer(opt, asynq.Config{...})` with:
    - Concurrency: 5 (per user decision)
    - ErrorHandler: `asynq.ErrorHandlerFunc(handleTaskError)` (pass logger)
    - Logger: wrap slog logger to satisfy asynq.Logger interface (asynq expects a Logger with Debug/Info/Warn/Error/Fatal methods)
    - ShutdownTimeout: 30 * time.Second
  - Create `asynq.NewServeMux()`
  - Register a placeholder handler for TaskGenerateBriefing that logs receipt and returns nil (Phase 4 will implement real logic). The placeholder should:
    - Unmarshal payload to get briefing_id
    - Log: "Processing briefing:generate task (briefing_id=X) - placeholder handler"
    - Return nil (success)
  - Call `srv.Run(mux)` and return error
- Create unexported `handleTaskError(ctx context.Context, task *asynq.Task, err error)`:
  - Extract retried count via `asynq.GetRetryCount(ctx)` and maxRetry via `asynq.GetMaxRetry(ctx)`
  - Log the failure with task type, retry count, max retry, error
  - If retried >= maxRetry (final failure): log "Task moved to dead letter queue" with task type and payload
  - NOTE: Do NOT implement database status update here yet -- that requires database access in the worker, which is Phase 4 scope. Just log the final failure for now.
- Create an asynq.Logger adapter struct that wraps slog.Logger to satisfy the asynq.Logger interface (Debug, Info, Warn, Error, Fatal methods). Asynq's Logger interface expects methods like `Debug(args ...interface{})`, `Info(args ...interface{})`, etc.
  </action>
  <verify>
Run `go build ./...` to confirm all three files compile. Run `go vet ./...` to check for issues. Verify the worker package exports: `grep -c "func " internal/worker/*.go` should show functions across all three files.
  </verify>
  <done>Worker package has: worker.go (Run with Asynq server, error handler, placeholder task handler), tasks.go (client singleton, task constants, EnqueueGenerateBriefing), logging.go (slog factory with level/format config). All compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire mode-switching into main.go and update Makefile</name>
  <files>cmd/server/main.go, Makefile</files>
  <action>
**cmd/server/main.go changes:**

1. Add imports: `"flag"`, `"github.com/jimdaga/first-sip/internal/worker"`
2. At the very start of main(), before config.Load():
   - Parse `--worker` flag: `workerMode := flag.Bool("worker", false, "Run in worker mode")`
   - Call `flag.Parse()`
3. After config.Load(), add Asynq client initialization (runs in BOTH modes so server can enqueue tasks):
   - If `cfg.RedisURL != ""`:
     - `worker.InitClient(cfg.RedisURL)` with error check (log.Fatalf on failure)
     - `defer worker.CloseClient()`
4. After encryption + database initialization, add the mode branch:
   - If `*workerMode`:
     - Log: "Starting in WORKER mode"
     - Call `worker.Run(cfg)` with error check (log.Fatalf on failure)
     - Return (do not start web server)
5. After the mode branch check (server mode continues), add embedded worker for development:
   - If `cfg.Env == "development" && cfg.RedisURL != ""`:
     - Log: "Starting embedded worker for development"
     - `go func() { if err := worker.Run(cfg); err != nil { log.Printf("Embedded worker error: %v", err) } }()`
6. The rest of main.go (Gin router setup, routes, r.Run) stays exactly as-is.

**Key structure of main() after changes:**
```
flag.Parse()
cfg := config.Load()
InitEncryption (existing)
InitClient (new - both modes)
Database init (existing)
if *workerMode { worker.Run(); return }
if dev && redisURL { go worker.Run() }  // embedded worker
Gin router setup (existing)
r.Run() (existing)
```

**Makefile changes:**
- Update the `dev` target echo message from "Ensure Postgres is running" to "Ensure Postgres and Redis are running" (since docker compose now starts both)
- The dev target already runs `go run cmd/server/main.go` which will start the embedded worker automatically in development mode, so no --worker flag needed for dev
- Add a new target `worker` for running standalone worker mode:
  ```
  worker: templ-generate
  	go run cmd/server/main.go --worker
  ```
- Add `worker` to the .PHONY list at the top
  </action>
  <verify>
Run `go build ./...` to confirm main.go compiles with all new imports. Run `go vet ./...` to check for issues. Verify flag is parsed: `grep "workerMode" cmd/server/main.go` should show the flag definition and usage.
  </verify>
  <done>main.go has --worker flag, Asynq client init in both modes, worker-only branch, embedded worker in dev mode. Makefile has updated dev message and new worker target.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete background job infrastructure</name>
  <files>none</files>
  <action>
Human verifies the complete Asynq background job infrastructure: Redis + Asynqmon in Docker Compose, worker package with server/client/logging, mode-switching binary, embedded worker in development.

Steps:
1. Start infrastructure: `make db-up` then `docker compose ps` -- expect postgres, redis, asynqmon all running/healthy
2. Source env and start app: `source env.local && make dev` -- expect "Starting embedded worker for development" in logs plus normal server on :8080
3. Open http://localhost:8081 -- expect Asynqmon dashboard (empty queues is fine)
4. Open http://localhost:8080/health -- expect {"status":"ok"}
5. Open http://localhost:8080/login -- expect login page renders
6. (Optional) Test standalone: `go run cmd/server/main.go --worker` -- expect "Starting in WORKER mode"
  </action>
  <verify>All 5 verification steps pass. Existing functionality (auth, health, database) unaffected.</verify>
  <done>Background job infrastructure verified: Redis running, worker connects, Asynqmon accessible, existing routes intact.</done>
</task>

</tasks>

<verification>
1. `docker compose ps` shows redis (healthy) and asynqmon (running) alongside postgres
2. `make dev` starts both web server and embedded worker
3. http://localhost:8081 shows Asynqmon dashboard
4. http://localhost:8080/health returns 200
5. `go run cmd/server/main.go --worker` starts in standalone worker mode
6. `go build ./...` and `go vet ./...` pass cleanly
</verification>

<success_criteria>
- Worker package exists at internal/worker/ with worker.go, tasks.go, logging.go
- Binary supports --worker flag for standalone worker mode
- Development mode embeds worker in same process (no separate terminal needed)
- Asynq server configured: 5 concurrency, 3 max retries, 30s shutdown timeout
- Task enqueue helper (EnqueueGenerateBriefing) ready for Phase 4 HTTP handlers
- Structured logging via slog with configurable level/format
- Placeholder task handler processes briefing:generate tasks (logs and succeeds)
- Error handler logs failures and identifies dead-lettered tasks
- All existing functionality (auth, database, health) unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/03-background-job-infrastructure/03-02-SUMMARY.md`
</output>
