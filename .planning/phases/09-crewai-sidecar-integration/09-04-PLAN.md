---
phase: 09-crewai-sidecar-integration
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/worker/worker.go
  - internal/worker/tasks.go
  - cmd/server/main.go
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Asynq task handler for plugin execution creates a PluginRun record and publishes to Redis Stream"
    - "streams.Publisher is initialized in main.go and passed to the worker"
    - "Plugin execution task can be enqueued with plugin name, user ID, and settings"
  artifacts:
    - path: "internal/worker/worker.go"
      provides: "handleExecutePlugin task handler creating PluginRun and publishing to streams"
      contains: "streams.Publisher"
    - path: "internal/worker/tasks.go"
      provides: "TaskExecutePlugin constant and EnqueueExecutePlugin function"
      contains: "TaskExecutePlugin"
    - path: "cmd/server/main.go"
      provides: "Publisher initialization and wiring into worker"
      contains: "streams.NewPublisher"
  key_links:
    - from: "internal/worker/worker.go"
      to: "internal/streams/producer.go"
      via: "Publisher.PublishPluginRequest call in handleExecutePlugin"
      pattern: "publisher\\.PublishPluginRequest"
    - from: "internal/worker/worker.go"
      to: "internal/plugins/models.go"
      via: "db.Create(&pluginRun) before publishing"
      pattern: "db\\..*Create.*PluginRun"
    - from: "cmd/server/main.go"
      to: "internal/streams/producer.go"
      via: "streams.NewPublisher initialization"
      pattern: "streams\\.NewPublisher"
---

<objective>
Wire the streams.Publisher into the worker's plugin execution flow so Go actually publishes plugin execution requests to the Redis Stream, closing the gap between the existing Publisher code and the existing Python consumer.

Purpose: Phase 09 built both ends of the Go-to-CrewAI pipeline (Go publisher, Python consumer, Python executor, Python result publisher, Go result consumer) but never connected the trigger. The worker still routes through the n8n webhook pathway. This plan adds the missing connection: a new Asynq task handler that creates a PluginRun database record and publishes to the Redis Stream.

Output: Working end-to-end path from Asynq task enqueue -> PluginRun creation -> Redis Stream publish -> (existing Python consumer picks up)
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/09-crewai-sidecar-integration/09-VERIFICATION.md

# Key source files
@internal/worker/worker.go
@internal/worker/tasks.go
@internal/streams/producer.go
@internal/streams/types.go
@internal/streams/handler.go
@internal/plugins/models.go
@cmd/server/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add plugin execution task type, handler, and Publisher wiring</name>
  <files>
    internal/worker/tasks.go
    internal/worker/worker.go
    cmd/server/main.go
  </files>
  <action>
**1. internal/worker/tasks.go — Add TaskExecutePlugin constant and enqueue function:**

Add a new task type constant alongside the existing ones:
```go
TaskExecutePlugin = "plugin:execute"
```

Add an `EnqueueExecutePlugin` function that accepts `pluginID uint`, `userID uint`, `pluginName string`, and `settings map[string]interface{}`. The payload should be a JSON object with fields: `plugin_id`, `user_id`, `plugin_name`, `settings`. Use `asynq.MaxRetry(2)`, `asynq.Timeout(10*time.Minute)` (CrewAI workflows are long-running), `asynq.Retention(24*time.Hour)`, `asynq.Unique(30*time.Minute)` to prevent duplicate plugin executions.

**2. internal/worker/worker.go — Add handleExecutePlugin handler and wire Publisher:**

Add imports for `"github.com/google/uuid"`, `"github.com/jimdaga/first-sip/internal/plugins"`, and `"github.com/jimdaga/first-sip/internal/streams"`.

Change the `Run`, `Start`, and `newServer` function signatures to accept a `*streams.Publisher` parameter alongside the existing `*webhook.Client`. The publisher can be nil (graceful degradation — if nil, log a warning and skip stream publishing).

Add `handleExecutePlugin(logger, db, publisher)` handler function that:
1. Unmarshals the task payload to get `plugin_id`, `user_id`, `plugin_name`, `settings`
2. Generates a unique `plugin_run_id` using `uuid.New().String()`
3. Creates a `plugins.PluginRun` record in the database with status "pending", the generated `plugin_run_id`, `user_id`, `plugin_id`, and input (JSON-marshaled settings). Sets `StartedAt` to `time.Now()`.
4. If publisher is nil, updates PluginRun status to "failed" with error "streams publisher not configured" and returns `asynq.SkipRetry`
5. Builds a `streams.PluginRequest{PluginRunID, PluginName, UserID, Settings}` and calls `publisher.PublishPluginRequest(ctx, req)`
6. If publish fails, updates PluginRun status to "failed" with the error message and returns the error (retryable)
7. If publish succeeds, updates PluginRun status to "processing" and logs the stream message ID
8. Returns nil

Register the new handler in `newServer`: `mux.HandleFunc(TaskExecutePlugin, handleExecutePlugin(logger, db, publisher))`

**3. cmd/server/main.go — Initialize Publisher and pass to worker:**

After the existing `webhookClient` initialization (around line 50), add Publisher initialization:
```go
var publisher *streams.Publisher
if cfg.RedisURL != "" {
    var err error
    publisher, err = streams.NewPublisher(cfg.RedisURL)
    if err != nil {
        log.Printf("Warning: streams publisher failed to initialize: %v", err)
    } else {
        defer publisher.Close()
    }
}
```

Update all calls to `worker.Run(cfg, db, webhookClient)` and `worker.Start(cfg, db, webhookClient)` to also pass `publisher`:
- Line ~113: `worker.Run(cfg, db, webhookClient, publisher)`
- Line ~126: `worker.Start(cfg, db, webhookClient, publisher)`

**Important: Do NOT remove the existing handleGenerateBriefing handler or the webhook client.** The n8n pathway must remain functional as a fallback. Both handlers coexist — handleGenerateBriefing for legacy briefing generation, handleExecutePlugin for the new plugin/CrewAI pathway.

**Dependencies:** Run `go get github.com/google/uuid` if not already in go.mod.
  </action>
  <verify>
Run `cd /Users/jim/git/jimdaga/first-sip && go build ./...` — must compile without errors.

Run `grep -n "PublishPluginRequest" internal/worker/worker.go` — must find at least one call.

Run `grep -n "TaskExecutePlugin" internal/worker/tasks.go` — must find the constant definition.

Run `grep -n "streams.NewPublisher" cmd/server/main.go` — must find Publisher initialization.

Run `grep -n "PluginRun" internal/worker/worker.go` — must find PluginRun record creation.

Run `make test` — existing tests must still pass (the new handler is additive, not modifying existing behavior).
  </verify>
  <done>
1. `TaskExecutePlugin` constant and `EnqueueExecutePlugin` function exist in tasks.go
2. `handleExecutePlugin` handler in worker.go creates a PluginRun record and calls `publisher.PublishPluginRequest`
3. `streams.NewPublisher` is initialized in main.go and passed through to the worker
4. Existing handleGenerateBriefing and webhook pathway remain untouched
5. `go build ./...` compiles successfully
6. `make test` passes
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `grep -rn "PublishPluginRequest" internal/worker/` shows the call from handleExecutePlugin
3. `grep -rn "streams.NewPublisher" cmd/server/` shows Publisher initialization
4. `grep -rn "PluginRun" internal/worker/worker.go` shows record creation before publishing
5. `grep -rn "TaskExecutePlugin" internal/worker/tasks.go` shows the new task type
6. `make test` passes (no regressions)
</verification>

<success_criteria>
- The Go worker has a code path from Asynq task -> PluginRun creation -> streams.Publisher.PublishPluginRequest -> Redis Stream
- The Publisher is properly initialized in main.go and passed to the worker
- The existing n8n webhook pathway remains functional (no breaking changes)
- The full codebase compiles and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-crewai-sidecar-integration/09-04-SUMMARY.md`
</output>
