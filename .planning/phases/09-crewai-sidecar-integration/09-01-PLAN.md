---
phase: 09-crewai-sidecar-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/streams/types.go
  - internal/streams/producer.go
  - internal/streams/consumer.go
  - internal/streams/handler.go
  - cmd/server/main.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "Go can publish a plugin execution request to Redis Stream plugin:requests"
    - "Go can consume plugin results from Redis Stream plugin:results via consumer group"
    - "Go result handler updates PluginRun records in database based on stream results"
    - "ResultConsumer runs as a background goroutine in both worker and embedded dev mode"
  artifacts:
    - path: "internal/streams/types.go"
      provides: "Shared types for Redis Stream messages (PluginRequest, PluginResult)"
      contains: "PluginRequest"
    - path: "internal/streams/producer.go"
      provides: "Publisher wrapping go-redis XAdd for plugin:requests stream"
      contains: "PublishPluginRequest"
    - path: "internal/streams/consumer.go"
      provides: "ResultConsumer wrapping go-redis XReadGroup for plugin:results stream"
      contains: "ConsumeResults"
    - path: "internal/streams/handler.go"
      provides: "HandlePluginResult that updates PluginRun records from stream results"
      contains: "HandlePluginResult"
  key_links:
    - from: "internal/streams/producer.go"
      to: "redis"
      via: "go-redis/v9 XAdd"
      pattern: "rdb\\.XAdd"
    - from: "internal/streams/consumer.go"
      to: "redis"
      via: "go-redis/v9 XReadGroup with consumer group"
      pattern: "rdb\\.XReadGroup"
    - from: "internal/streams/handler.go"
      to: "internal/plugins/models.go"
      via: "GORM update on PluginRun"
      pattern: "db\\.Model.*PluginRun"
    - from: "cmd/server/main.go"
      to: "internal/streams"
      via: "StartResultConsumer goroutine in worker and embedded modes"
      pattern: "streams\\.StartResultConsumer"
---

<objective>
Build the Go-side Redis Streams infrastructure for publishing plugin execution requests and consuming CrewAI results, and wire the result consumer into the application lifecycle.

Purpose: Provides the Go half of the two-stream communication pattern (Go -> plugin:requests, plugin:results -> Go). This is the foundation that lets Go trigger plugin execution and receive results asynchronously from the Python sidecar. The consumer is started as a background goroutine so results are processed automatically.

Output: `internal/streams/` package with Publisher, ResultConsumer, message types, a result handler that updates PluginRun database records, and lifecycle wiring in main.go.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-crewai-sidecar-integration/09-RESEARCH.md
@internal/plugins/models.go
@internal/worker/tasks.go
@internal/worker/worker.go
@internal/worker/scheduler.go
@internal/config/config.go
@cmd/server/main.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redis Streams types and publisher</name>
  <files>internal/streams/types.go, internal/streams/producer.go, go.mod</files>
  <action>
Create `internal/streams/types.go` with:
- Stream name constants: `StreamPluginRequests = "plugin:requests"` and `StreamPluginResults = "plugin:results"`
- Consumer group constants: `GroupCrewAIWorkers = "crewai-workers"` (Python side) and `GroupGoWorkers = "go-workers"` (Go side)
- Schema version constant: `SchemaVersionV1 = "v1"`
- `PluginRequest` struct with JSON tags: `PluginRunID string`, `PluginName string`, `UserID uint`, `Settings map[string]interface{}`
- `PluginResult` struct with JSON tags: `PluginRunID string`, `Status string` (completed/failed), `Output string` (the briefing content), `Error string` (error message if failed)

Create `internal/streams/producer.go` with:
- `Publisher` struct holding `*redis.Client`
- `NewPublisher(redisURL string) (*Publisher, error)` — parses URL with `redis.ParseURL`, creates client
- `PublishPluginRequest(ctx context.Context, req PluginRequest) (string, error)` — marshals req to JSON, calls `rdb.XAdd` with stream `StreamPluginRequests`, auto-generated ID (`*`), `MaxLen` approx 10000, values map with keys `payload` (JSON string), `published_at` (unix timestamp), `schema_version` ("v1"). Returns message ID.
- `Close() error` — closes Redis client

Promote `github.com/redis/go-redis/v9` from indirect to direct dependency in go.mod by running `go get github.com/redis/go-redis/v9`.

Follow existing codebase patterns: use `fmt.Errorf` with `%w` for error wrapping, `log/slog` is available but not needed here (caller logs), keep functions focused and small.
  </action>
  <verify>Run `go build ./internal/streams/...` — must compile with no errors. Run `go vet ./internal/streams/...` — must pass.</verify>
  <done>types.go defines PluginRequest, PluginResult, stream constants. producer.go has Publisher with PublishPluginRequest. go-redis/v9 is a direct dependency.</done>
</task>

<task type="auto">
  <name>Task 2: Redis Streams consumer and result handler</name>
  <files>internal/streams/consumer.go, internal/streams/handler.go</files>
  <action>
Create `internal/streams/consumer.go` with:
- `ResultConsumer` struct holding `*redis.Client`, `groupName string`, `consumerName string`
- `NewResultConsumer(redisURL, consumerName string) (*ResultConsumer, error)` — parses URL, creates client, creates consumer group on `StreamPluginResults` with group name `GroupGoWorkers` and start ID `"0"` using `XGroupCreateMkStream`. Ignore `BUSYGROUP` error (group already exists) by checking error string contains "BUSYGROUP".
- `ConsumeResults(ctx context.Context, handler func(PluginResult) error) error` — blocking loop that:
  1. Checks `ctx.Done()` for graceful shutdown
  2. Calls `rdb.XReadGroup` with group `GroupGoWorkers`, consumer name, streams `[StreamPluginResults, ">"]`, count 10, block 5 seconds
  3. On `redis.Nil` error (no messages), continues loop
  4. For each message: extracts `payload` string from values, unmarshals to `PluginResult`, calls handler function
  5. On successful handler call: ACKs message with `rdb.XAck`
  6. On handler error: logs with `slog.Error` but continues (message stays in PEL for retry)
  7. Returns `ctx.Err()` when context cancelled
- `Close() error` — closes Redis client
- `StartResultConsumer(redisURL string, db *gorm.DB) (stop func(), err error)` — convenience function that:
  1. Creates a `NewResultConsumer(redisURL, "go-worker-1")`
  2. Creates a cancellable context via `context.WithCancel(context.Background())`
  3. Launches `consumer.ConsumeResults(ctx, HandlePluginResult(db))` in a goroutine
  4. Returns a `stop` function that calls `cancel()` then `consumer.Close()`
  5. Logs "Result consumer started" on success

This follows the exact same `(stop func(), err error)` return pattern as `worker.StartScheduler()` and `worker.Start()` so main.go can manage its lifecycle consistently.

Create `internal/streams/handler.go` with:
- `HandlePluginResult(db *gorm.DB) func(PluginResult) error` — returns a closure that:
  1. Finds PluginRun by `PluginRunID` field (not GORM ID): `db.Where("plugin_run_id = ?", result.PluginRunID).First(&pluginRun)`
  2. If not found: return error (message stays in PEL)
  3. If result.Status == "completed": update PluginRun with `Status: PluginRunStatusCompleted`, `Output: datatypes.JSON(result.Output)`, `CompletedAt: time.Now()`
  4. If result.Status == "failed": update PluginRun with `Status: PluginRunStatusFailed`, `ErrorMessage: result.Error`, `CompletedAt: time.Now()`
  5. Log the outcome with slog (plugin_run_id, status)

Import `internal/plugins` for PluginRun model and status constants. Use `log/slog` for structured logging consistent with the worker package. Use `gorm.io/datatypes` for JSON field, `gorm.io/gorm` for DB.
  </action>
  <verify>Run `go build ./internal/streams/...` — must compile. Run `go vet ./internal/streams/...` — must pass. Verify handler imports plugins package: `grep -r "plugins" internal/streams/handler.go`. Verify StartResultConsumer exists: `grep "func StartResultConsumer" internal/streams/consumer.go`.</verify>
  <done>consumer.go has ResultConsumer with ConsumeResults loop using XReadGroup + XACK pattern, plus StartResultConsumer convenience function matching worker lifecycle pattern. handler.go has HandlePluginResult that updates PluginRun records based on stream results. Both compile cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: Wire ResultConsumer into application lifecycle</name>
  <files>cmd/server/main.go</files>
  <action>
Update `cmd/server/main.go` to start the ResultConsumer in both worker mode and embedded dev mode, following the same pattern used for `worker.StartScheduler()`.

Add import: `"github.com/jimdaga/first-sip/internal/streams"`

**In worker mode block** (around line 95, after `stopScheduler` setup and before `worker.Run()`):
```go
// Start Redis Streams result consumer for CrewAI responses
stopResultConsumer, err := streams.StartResultConsumer(cfg.RedisURL, db)
if err != nil {
    log.Printf("Warning: result consumer failed to start: %v", err)
} else {
    defer stopResultConsumer()
}
```
Use non-fatal error handling (log warning, not fatal) matching the plugin initialization pattern. The Asynq worker can still process v1.0 briefings even if the streams consumer fails.

**In embedded dev mode block** (around line 113, after `stopScheduler` setup):
```go
// Start embedded result consumer for CrewAI responses
log.Println("Starting embedded result consumer for development")
stopResultConsumer, err := streams.StartResultConsumer(cfg.RedisURL, db)
if err != nil {
    log.Printf("Warning: result consumer failed to start: %v", err)
}
```

**In the shutdown sequence** (around line 245, after stopScheduler and before stopWorker):
```go
// Shut down embedded result consumer
if stopResultConsumer != nil {
    stopResultConsumer()
}
```

Declare `var stopResultConsumer func()` at the appropriate scope so it is accessible in both the embedded dev setup block and the shutdown sequence. Follow the same variable pattern as `stopWorker` and `stopScheduler`.

Key: The `stopResultConsumer` variable in embedded mode must be declared at the same scope as `stopWorker` and `stopScheduler` (before the `if cfg.Env == "development"` block) so the shutdown sequence can access it.
  </action>
  <verify>Run `go build ./cmd/server/...` — must compile with no errors. Run `go vet ./cmd/server/...` — must pass. Verify streams import: `grep "streams" cmd/server/main.go`. Verify StartResultConsumer called in both modes: `grep -c "StartResultConsumer" cmd/server/main.go` should return 2 (worker mode + embedded mode).</verify>
  <done>cmd/server/main.go starts ResultConsumer goroutine in both worker mode and embedded dev mode, with graceful shutdown via stop function. Non-fatal error handling ensures v1.0 functionality works even if streams consumer fails.</done>
</task>

</tasks>

<verification>
- `go build ./internal/streams/...` compiles without errors
- `go build ./cmd/server/...` compiles without errors
- `go vet ./internal/streams/... ./cmd/server/...` passes
- `go-redis/v9` appears as direct dependency in go.mod (not just indirect)
- types.go exports: PluginRequest, PluginResult, StreamPluginRequests, StreamPluginResults
- producer.go exports: Publisher, NewPublisher, PublishPluginRequest
- consumer.go exports: ResultConsumer, NewResultConsumer, ConsumeResults, StartResultConsumer
- handler.go exports: HandlePluginResult
- handler.go imports internal/plugins for PluginRun model
- cmd/server/main.go imports internal/streams and calls StartResultConsumer in both worker and embedded modes
- cmd/server/main.go calls stopResultConsumer() during shutdown
</verification>

<success_criteria>
- Go can publish structured plugin execution requests to Redis Stream
- Go can consume plugin results via consumer group with ACK pattern
- Result handler maps stream results to PluginRun database updates
- ResultConsumer is started as a background goroutine and shut down gracefully
- All code compiles and passes go vet
</success_criteria>

<output>
After completion, create `.planning/phases/09-crewai-sidecar-integration/09-01-SUMMARY.md`
</output>
