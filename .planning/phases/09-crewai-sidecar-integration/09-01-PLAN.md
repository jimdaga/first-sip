---
phase: 09-crewai-sidecar-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/streams/types.go
  - internal/streams/producer.go
  - internal/streams/consumer.go
  - internal/streams/handler.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "Go can publish a plugin execution request to Redis Stream plugin:requests"
    - "Go can consume plugin results from Redis Stream plugin:results via consumer group"
    - "Go result handler updates PluginRun records in database based on stream results"
  artifacts:
    - path: "internal/streams/types.go"
      provides: "Shared types for Redis Stream messages (PluginRequest, PluginResult)"
      contains: "PluginRequest"
    - path: "internal/streams/producer.go"
      provides: "Publisher wrapping go-redis XAdd for plugin:requests stream"
      contains: "PublishPluginRequest"
    - path: "internal/streams/consumer.go"
      provides: "ResultConsumer wrapping go-redis XReadGroup for plugin:results stream"
      contains: "ConsumeResults"
    - path: "internal/streams/handler.go"
      provides: "HandlePluginResult that updates PluginRun records from stream results"
      contains: "HandlePluginResult"
  key_links:
    - from: "internal/streams/producer.go"
      to: "redis"
      via: "go-redis/v9 XAdd"
      pattern: "rdb\\.XAdd"
    - from: "internal/streams/consumer.go"
      to: "redis"
      via: "go-redis/v9 XReadGroup with consumer group"
      pattern: "rdb\\.XReadGroup"
    - from: "internal/streams/handler.go"
      to: "internal/plugins/models.go"
      via: "GORM update on PluginRun"
      pattern: "db\\.Model.*PluginRun"
---

<objective>
Build the Go-side Redis Streams infrastructure for publishing plugin execution requests and consuming CrewAI results.

Purpose: Provides the Go half of the two-stream communication pattern (Go -> plugin:requests, plugin:results -> Go). This is the foundation that lets Go trigger plugin execution and receive results asynchronously from the Python sidecar.

Output: `internal/streams/` package with Publisher, ResultConsumer, message types, and a result handler that updates PluginRun database records.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-crewai-sidecar-integration/09-RESEARCH.md
@internal/plugins/models.go
@internal/worker/tasks.go
@internal/config/config.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Redis Streams types and publisher</name>
  <files>internal/streams/types.go, internal/streams/producer.go, go.mod</files>
  <action>
Create `internal/streams/types.go` with:
- Stream name constants: `StreamPluginRequests = "plugin:requests"` and `StreamPluginResults = "plugin:results"`
- Consumer group constants: `GroupCrewAIWorkers = "crewai-workers"` (Python side) and `GroupGoWorkers = "go-workers"` (Go side)
- Schema version constant: `SchemaVersionV1 = "v1"`
- `PluginRequest` struct with JSON tags: `PluginRunID string`, `PluginName string`, `UserID uint`, `Settings map[string]interface{}`
- `PluginResult` struct with JSON tags: `PluginRunID string`, `Status string` (completed/failed), `Output string` (the briefing content), `Error string` (error message if failed)

Create `internal/streams/producer.go` with:
- `Publisher` struct holding `*redis.Client`
- `NewPublisher(redisURL string) (*Publisher, error)` — parses URL with `redis.ParseURL`, creates client
- `PublishPluginRequest(ctx context.Context, req PluginRequest) (string, error)` — marshals req to JSON, calls `rdb.XAdd` with stream `StreamPluginRequests`, auto-generated ID (`*`), `MaxLen` approx 10000, values map with keys `payload` (JSON string), `published_at` (unix timestamp), `schema_version` ("v1"). Returns message ID.
- `Close() error` — closes Redis client

Promote `github.com/redis/go-redis/v9` from indirect to direct dependency in go.mod by running `go get github.com/redis/go-redis/v9`.

Follow existing codebase patterns: use `fmt.Errorf` with `%w` for error wrapping, `log/slog` is available but not needed here (caller logs), keep functions focused and small.
  </action>
  <verify>Run `go build ./internal/streams/...` — must compile with no errors. Run `go vet ./internal/streams/...` — must pass.</verify>
  <done>types.go defines PluginRequest, PluginResult, stream constants. producer.go has Publisher with PublishPluginRequest. go-redis/v9 is a direct dependency.</done>
</task>

<task type="auto">
  <name>Task 2: Redis Streams consumer and result handler</name>
  <files>internal/streams/consumer.go, internal/streams/handler.go</files>
  <action>
Create `internal/streams/consumer.go` with:
- `ResultConsumer` struct holding `*redis.Client`, `groupName string`, `consumerName string`
- `NewResultConsumer(redisURL, consumerName string) (*ResultConsumer, error)` — parses URL, creates client, creates consumer group on `StreamPluginResults` with group name `GroupGoWorkers` and start ID `"0"` using `XGroupCreateMkStream`. Ignore `BUSYGROUP` error (group already exists) by checking error string contains "BUSYGROUP".
- `ConsumeResults(ctx context.Context, handler func(PluginResult) error) error` — blocking loop that:
  1. Checks `ctx.Done()` for graceful shutdown
  2. Calls `rdb.XReadGroup` with group `GroupGoWorkers`, consumer name, streams `[StreamPluginResults, ">"]`, count 10, block 5 seconds
  3. On `redis.Nil` error (no messages), continues loop
  4. For each message: extracts `payload` string from values, unmarshals to `PluginResult`, calls handler function
  5. On successful handler call: ACKs message with `rdb.XAck`
  6. On handler error: logs with `slog.Error` but continues (message stays in PEL for retry)
  7. Returns `ctx.Err()` when context cancelled
- `Close() error` — closes Redis client

Create `internal/streams/handler.go` with:
- `HandlePluginResult(db *gorm.DB) func(PluginResult) error` — returns a closure that:
  1. Finds PluginRun by `PluginRunID` field (not GORM ID): `db.Where("plugin_run_id = ?", result.PluginRunID).First(&pluginRun)`
  2. If not found: return error (message stays in PEL)
  3. If result.Status == "completed": update PluginRun with `Status: PluginRunStatusCompleted`, `Output: datatypes.JSON(result.Output)`, `CompletedAt: time.Now()`
  4. If result.Status == "failed": update PluginRun with `Status: PluginRunStatusFailed`, `ErrorMessage: result.Error`, `CompletedAt: time.Now()`
  5. Log the outcome with slog (plugin_run_id, status)

Import `internal/plugins` for PluginRun model and status constants. Use `log/slog` for structured logging consistent with the worker package. Use `gorm.io/datatypes` for JSON field, `gorm.io/gorm` for DB.
  </action>
  <verify>Run `go build ./internal/streams/...` — must compile. Run `go vet ./internal/streams/...` — must pass. Verify handler imports plugins package: `grep -r "plugins" internal/streams/handler.go`.</verify>
  <done>consumer.go has ResultConsumer with ConsumeResults loop using XReadGroup + XACK pattern. handler.go has HandlePluginResult that updates PluginRun records based on stream results. Both compile cleanly.</done>
</task>

</tasks>

<verification>
- `go build ./internal/streams/...` compiles without errors
- `go vet ./internal/streams/...` passes
- `go-redis/v9` appears as direct dependency in go.mod (not just indirect)
- types.go exports: PluginRequest, PluginResult, StreamPluginRequests, StreamPluginResults
- producer.go exports: Publisher, NewPublisher, PublishPluginRequest
- consumer.go exports: ResultConsumer, NewResultConsumer, ConsumeResults
- handler.go exports: HandlePluginResult
- handler.go imports internal/plugins for PluginRun model
</verification>

<success_criteria>
- Go can publish structured plugin execution requests to Redis Stream
- Go can consume plugin results via consumer group with ACK pattern
- Result handler maps stream results to PluginRun database updates
- All code compiles and passes go vet
</success_criteria>

<output>
After completion, create `.planning/phases/09-crewai-sidecar-integration/09-01-SUMMARY.md`
</output>
