---
phase: 10-per-user-scheduling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/database/migrations/000006_add_schedule_to_user_plugin_configs.up.sql
  - internal/database/migrations/000006_add_schedule_to_user_plugin_configs.down.sql
  - internal/plugins/models.go
  - internal/worker/scheduler.go
  - internal/worker/tasks.go
autonomous: true

must_haves:
  truths:
    - "UserPluginConfig has cron_expression and timezone columns in the database"
    - "isDue correctly evaluates cron expressions in the user's local timezone"
    - "Per-minute scheduler queries enabled configs and enqueues plugin:execute for due pairs"
    - "Redis caches last-run timestamps to avoid redundant DB queries"
    - "Cold cache does not mass-fire all scheduled pairs on first start"
  artifacts:
    - path: "internal/database/migrations/000006_add_schedule_to_user_plugin_configs.up.sql"
      provides: "Schema migration adding cron_expression and timezone columns"
      contains: "ALTER TABLE user_plugin_configs"
    - path: "internal/database/migrations/000006_add_schedule_to_user_plugin_configs.down.sql"
      provides: "Rollback migration"
      contains: "DROP COLUMN"
    - path: "internal/plugins/models.go"
      provides: "CronExpression and Timezone fields on UserPluginConfig struct"
      contains: "CronExpression"
    - path: "internal/worker/scheduler.go"
      provides: "StartPerMinuteScheduler, handlePerMinuteScheduler, isDue, Redis cache helpers"
      exports: ["StartPerMinuteScheduler"]
    - path: "internal/worker/tasks.go"
      provides: "TaskPerMinuteScheduler constant"
      contains: "TaskPerMinuteScheduler"
  key_links:
    - from: "internal/worker/scheduler.go"
      to: "internal/plugins/models.go"
      via: "GORM query on UserPluginConfig with Preload"
      pattern: "Preload.*Plugin.*Find.*configs"
    - from: "internal/worker/scheduler.go"
      to: "internal/worker/tasks.go"
      via: "EnqueueExecutePlugin call"
      pattern: "EnqueueExecutePlugin"
    - from: "internal/worker/scheduler.go"
      to: "redis"
      via: "HSET/HGET for last-run cache"
      pattern: "HGet|HSet.*scheduler:last_run"
---

<objective>
Build the per-user per-plugin scheduling engine: database migration, model changes, cron evaluation logic, Redis last-run cache, and the per-minute Asynq scheduler handler.

Purpose: Replace the global one-size-fits-all cron with a database-backed system where each user-plugin pair has its own schedule evaluated in the user's timezone.
Output: Migration files, updated UserPluginConfig model, fully implemented scheduler.go with StartPerMinuteScheduler and all supporting functions.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-per-user-scheduling/10-RESEARCH.md
@internal/plugins/models.go
@internal/worker/scheduler.go
@internal/worker/tasks.go
@internal/worker/worker.go
@internal/models/user.go
@internal/database/migrations/000005_create_plugins.up.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration and model update for schedule fields</name>
  <files>
    internal/database/migrations/000006_add_schedule_to_user_plugin_configs.up.sql
    internal/database/migrations/000006_add_schedule_to_user_plugin_configs.down.sql
    internal/plugins/models.go
  </files>
  <action>
Create SQL migration 000006_add_schedule_to_user_plugin_configs.up.sql:
- ALTER TABLE user_plugin_configs ADD COLUMN cron_expression VARCHAR(100) (nullable — no schedule means disabled)
- ALTER TABLE user_plugin_configs ADD COLUMN timezone VARCHAR(100) NOT NULL DEFAULT 'UTC'
- CREATE partial INDEX idx_user_plugin_configs_scheduled ON user_plugin_configs(enabled, cron_expression) WHERE deleted_at IS NULL AND enabled = true AND cron_expression IS NOT NULL
- This index accelerates the per-minute scheduler query

Create matching down migration:
- DROP INDEX IF EXISTS idx_user_plugin_configs_scheduled
- ALTER TABLE user_plugin_configs DROP COLUMN IF EXISTS cron_expression, DROP COLUMN IF EXISTS timezone

Update UserPluginConfig struct in internal/plugins/models.go:
- Add CronExpression string field: `gorm:"column:cron_expression"` (no not null — empty means no schedule)
- Add Timezone string field: `gorm:"column:timezone;not null;default:'UTC'"` (IANA timezone name)
- Keep all existing fields unchanged

Add a ValidateCronExpression function to internal/plugins/models.go:
- Uses robfig/cron/v3 Parser (cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow) to parse the expression
- Returns error if invalid, nil if valid
- This is used at write time (Phase 12 settings UI) and at evaluation time
  </action>
  <verify>
Run `make build` to confirm compilation. Run `make test` to confirm no regressions. Manually inspect that migration SQL is valid by reading the file.
  </verify>
  <done>
UserPluginConfig struct has CronExpression and Timezone fields. Migration 000006 exists with up and down files. ValidateCronExpression function parses cron expressions using robfig/cron/v3. Code compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Per-minute scheduler with timezone-aware cron evaluation and Redis cache</name>
  <files>
    internal/worker/scheduler.go
    internal/worker/tasks.go
  </files>
  <action>
Replace the entire contents of internal/worker/scheduler.go with the new per-minute scheduler. Delete StartScheduler completely.

Add to internal/worker/tasks.go:
- New constant: TaskPerMinuteScheduler = "scheduler:per_minute"
- Keep TaskGenerateBriefing, TaskExecutePlugin unchanged
- Delete TaskScheduledBriefingGeneration constant (the old global task type)

In the new scheduler.go, implement:

1. **StartPerMinuteScheduler(cfg *config.Config) (stop func(), err error)**
   - Create asynq.NewScheduler with redisOpt, Location: time.UTC (scheduler itself is UTC; timezone is per-user)
   - Create task with TaskPerMinuteScheduler, nil payload
   - Options: asynq.MaxRetry(0) (don't retry — next minute catches up), asynq.Timeout(50*time.Second), asynq.Unique(55*time.Second)
   - Register with "* * * * *" cron expression
   - Start scheduler, return shutdown function
   - Log startup with slog.Info

2. **handlePerMinuteScheduler(logger *slog.Logger, db *gorm.DB, rdb *redis.Client) func(context.Context, *asynq.Task) error**
   - Query: db.Preload("Plugin").Preload("User").Where("enabled = ? AND cron_expression IS NOT NULL AND cron_expression != ''", true).Find(&configs)
   - For each config:
     - Get lastRun from Redis cache via getLastRun()
     - Determine effective timezone: use cfg.Timezone if non-empty, otherwise fall back to cfg.User.Timezone (per research recommendation)
     - Call isDue(cfg.CronExpression, effectiveTimezone, lastRun)
     - If error, log warning and skip (non-fatal per existing pattern)
     - If not due, continue
     - Unmarshal cfg.Settings into map[string]interface{} (empty map on error)
     - Call EnqueueExecutePlugin(cfg.PluginID, cfg.UserID, cfg.Plugin.Name, settings)
     - On success, call setLastRun() to update Redis cache
     - Log each enqueued execution
   - Log summary: total configs evaluated, total enqueued, total skipped/errored

3. **isDue(cronExpr string, timezone string, lastRunAt time.Time) (bool, error)**
   - Return false if cronExpr is empty
   - Default timezone to "UTC" if empty
   - Validate timezone with time.LoadLocation; fall back to UTC if invalid
   - Prepend "CRON_TZ=" + timezone + " " + cronExpr
   - Parse with cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)
   - CRITICAL: If lastRunAt.IsZero(), set to time.Now().Add(-time.Minute) to prevent cold-cache mass-fire
   - Return !schedule.Next(lastRunAt).After(time.Now())

4. **Redis cache helpers** (private functions in scheduler.go):
   - const lastRunHashKey = "scheduler:last_run"
   - func fieldKey(userID, pluginID uint) string — returns "userID:pluginID"
   - func getLastRun(ctx, rdb, userID, pluginID) time.Time — HGET, parse int64, return time.Unix; return zero time on miss
   - func setLastRun(ctx, rdb, userID, pluginID, t) — HSET with Unix timestamp
   - func newSchedulerRedisClient(redisURL string) (*redis.Client, error) — parse URL, return client

Import robfig/cron/v3 as `cron "github.com/robfig/cron/v3"` and go-redis/v9 as `"github.com/redis/go-redis/v9"`. Both are already in go.mod (robfig as transitive dep via asynq, go-redis as direct dep).
  </action>
  <verify>
Run `make build` to confirm compilation. Run `make test` to confirm no regressions. Verify isDue logic manually: isDue("0 6 * * *", "America/Los_Angeles", time.Now().Add(-25*time.Hour)) should return true; isDue("0 6 * * *", "America/Los_Angeles", time.Now()) should return false (unless it happens to be exactly 6 AM PST).
  </verify>
  <done>
scheduler.go contains StartPerMinuteScheduler (replaces StartScheduler), handlePerMinuteScheduler, isDue with timezone support, and Redis HSET/HGET cache helpers. TaskPerMinuteScheduler constant exists in tasks.go. TaskScheduledBriefingGeneration constant is deleted. Code compiles with no new dependencies required.
  </done>
</task>

</tasks>

<verification>
- `make build` succeeds (all code compiles)
- `make test` passes (no regressions)
- Migration 000006 up/down files exist and contain valid SQL
- UserPluginConfig has CronExpression and Timezone fields
- scheduler.go exports StartPerMinuteScheduler (not StartScheduler)
- TaskPerMinuteScheduler constant defined, TaskScheduledBriefingGeneration removed
- isDue function handles: empty expression, invalid timezone fallback, cold cache protection, timezone-aware evaluation
</verification>

<success_criteria>
The per-minute scheduling engine is fully implemented: migration ready, model updated, cron evaluation with timezone support, Redis cache for last-run times, and the Asynq handler that queries the DB and enqueues due plugin executions. The old StartScheduler and TaskScheduledBriefingGeneration are removed. Code compiles but is not yet wired into main.go (that is Plan 02).
</success_criteria>

<output>
After completion, create `.planning/phases/10-per-user-scheduling/10-01-SUMMARY.md`
</output>
