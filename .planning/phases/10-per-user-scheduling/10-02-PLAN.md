---
phase: 10-per-user-scheduling
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - internal/worker/worker.go
  - cmd/server/main.go
  - internal/config/config.go
autonomous: true

must_haves:
  truths:
    - "Per-minute scheduler runs in both worker mode and embedded development mode"
    - "Global cron scheduler is fully removed — no StartScheduler calls remain"
    - "handleScheduledBriefingGeneration handler is removed from worker mux"
    - "Asynq server processes scheduler:per_minute on a critical queue with higher priority"
    - "BriefingSchedule and BriefingTimezone config fields are removed"
  artifacts:
    - path: "cmd/server/main.go"
      provides: "Wiring of StartPerMinuteScheduler in both worker and embedded modes"
      contains: "StartPerMinuteScheduler"
    - path: "internal/worker/worker.go"
      provides: "Mux handler for TaskPerMinuteScheduler, removal of old handler, critical queue config"
      contains: "TaskPerMinuteScheduler"
    - path: "internal/config/config.go"
      provides: "Removal of BriefingSchedule and BriefingTimezone fields"
  key_links:
    - from: "cmd/server/main.go"
      to: "internal/worker/scheduler.go"
      via: "StartPerMinuteScheduler call"
      pattern: "worker\\.StartPerMinuteScheduler"
    - from: "internal/worker/worker.go"
      to: "internal/worker/scheduler.go"
      via: "mux.HandleFunc for TaskPerMinuteScheduler -> handlePerMinuteScheduler"
      pattern: "mux\\.HandleFunc.*TaskPerMinuteScheduler.*handlePerMinuteScheduler"
---

<objective>
Wire the new per-minute scheduler into the application startup, remove all traces of the old global scheduler, and configure queue priorities so the scheduler task is never blocked by long-running plugin executions.

Purpose: Complete the transition from global cron to per-user scheduling by connecting the engine (Plan 01) to the application entry points and cleaning up dead code.
Output: Updated main.go, worker.go, and config.go with the new scheduler wired and old code removed.
</objective>

<execution_context>
@/Users/jim/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jim/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-per-user-scheduling/10-RESEARCH.md
@.planning/phases/10-per-user-scheduling/10-01-SUMMARY.md
@internal/worker/worker.go
@cmd/server/main.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire per-minute scheduler and add critical queue to Asynq server</name>
  <files>
    internal/worker/worker.go
    cmd/server/main.go
  </files>
  <action>
**internal/worker/worker.go changes:**

1. Update newServer to accept a *redis.Client parameter for the scheduler Redis cache:
   - Signature becomes: newServer(cfg *config.Config, db *gorm.DB, webhookClient *webhook.Client, publisher *streams.Publisher, schedulerCache *redis.Client)
   - Update Run() and Start() signatures to pass schedulerCache through to newServer

2. Update Asynq server config to support queue priorities:
   - Add Queues map: asynq.Config{ Queues: map[string]int{"critical": 6, "default": 3} }
   - This ensures the per-minute scheduler task (on critical queue) is processed before plugin:execute tasks

3. Register the new handler in the mux:
   - mux.HandleFunc(TaskPerMinuteScheduler, handlePerMinuteScheduler(logger, db, schedulerCache))
   - The handlePerMinuteScheduler function was created in Plan 01 in scheduler.go

4. Remove the old handler registration:
   - Delete: mux.HandleFunc(TaskScheduledBriefingGeneration, handleScheduledBriefingGeneration(logger, db))
   - Delete the entire handleScheduledBriefingGeneration function (lines ~102-177 in current worker.go)

**cmd/server/main.go changes:**

1. Create a scheduler Redis client near the top of main() (after config load, near publisher init):
   - Import the scheduler cache constructor: use redis.ParseURL + redis.NewClient pattern (same as streams)
   - var schedulerCache *redis.Client; if cfg.RedisURL != "" { opts, _ := redis.ParseURL(cfg.RedisURL); schedulerCache = redis.NewClient(opts); defer schedulerCache.Close() }

2. Worker mode branch (if *workerMode):
   - Replace: stopScheduler, err := worker.StartScheduler(cfg) with stopScheduler, err := worker.StartPerMinuteScheduler(cfg)
   - Update worker.Run call to pass schedulerCache

3. Embedded development mode branch (if cfg.Env == "development"):
   - Replace: stopScheduler, err = worker.StartScheduler(cfg) with stopScheduler, err = worker.StartPerMinuteScheduler(cfg)
   - Update worker.Start call to pass schedulerCache

4. Remove the import of config fields that are no longer used (BriefingSchedule, BriefingTimezone are read in StartScheduler which is deleted). No direct import changes needed in main.go since config.Load() still returns the struct.

5. Update the TaskPerMinuteScheduler Asynq task in StartPerMinuteScheduler (in scheduler.go from Plan 01) to use Queue("critical"):
   - Add asynq.Queue("critical") to the task options in StartPerMinuteScheduler
   - This ensures the per-minute task lands on the critical queue, matching the server's queue priority config
  </action>
  <verify>
Run `make build` to confirm compilation. Grep for "StartScheduler" — should NOT appear anywhere (only StartPerMinuteScheduler). Grep for "TaskScheduledBriefingGeneration" — should NOT appear anywhere. Grep for "handleScheduledBriefingGeneration" — should NOT appear anywhere. Run `make test` for regressions.
  </verify>
  <done>
StartPerMinuteScheduler is called in both worker mode and embedded mode in main.go. handlePerMinuteScheduler is registered in the Asynq mux. Asynq server has queue priorities (critical: 6, default: 3). schedulerCache Redis client is created and passed through. No references to StartScheduler, TaskScheduledBriefingGeneration, or handleScheduledBriefingGeneration remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove deprecated global scheduler config fields</name>
  <files>
    internal/config/config.go
  </files>
  <action>
In internal/config/config.go:

1. Remove BriefingSchedule field from the Config struct
2. Remove BriefingTimezone field from the Config struct
3. Remove the corresponding lines in Load():
   - Delete: BriefingSchedule: getEnvWithDefault("BRIEFING_SCHEDULE", "0 6 * * *")
   - Delete: BriefingTimezone: getEnvWithDefault("BRIEFING_TIMEZONE", "UTC")

These fields were only consumed by the old StartScheduler (now deleted). The per-minute scheduler reads schedule config from the database (UserPluginConfig.CronExpression and .Timezone), not from environment variables.

Verify no other file in the codebase references cfg.BriefingSchedule or cfg.BriefingTimezone. If any reference exists outside scheduler.go (which is already rewritten), update it accordingly.
  </action>
  <verify>
Run `make build` to confirm compilation. Grep for "BriefingSchedule" and "BriefingTimezone" across the entire codebase — should return zero matches. Run `make test` for regressions.
  </verify>
  <done>
Config struct no longer has BriefingSchedule or BriefingTimezone. No references to these fields exist anywhere in the codebase. The global scheduler config is fully retired in favor of per-user database-backed schedules.
  </done>
</task>

</tasks>

<verification>
- `make build` succeeds
- `make test` passes
- Zero grep matches for: StartScheduler (bare, not PerMinute), TaskScheduledBriefingGeneration, handleScheduledBriefingGeneration, BriefingSchedule, BriefingTimezone
- main.go calls StartPerMinuteScheduler in BOTH worker mode and embedded dev mode
- worker.go mux registers TaskPerMinuteScheduler handler
- Asynq server config includes queue priorities with "critical" queue
- schedulerCache Redis client created and passed through call chain
</verification>

<success_criteria>
The per-user scheduling system is fully wired end-to-end. The application starts with a per-minute scheduler that evaluates database-backed schedules in each user's timezone, enqueues plugin:execute tasks for due pairs, and caches last-run times in Redis. All traces of the old global scheduler (StartScheduler, BriefingSchedule, BriefingTimezone, TaskScheduledBriefingGeneration, handleScheduledBriefingGeneration) are removed. The critical queue ensures the scheduler is never delayed by long-running plugin tasks.
</success_criteria>

<output>
After completion, create `.planning/phases/10-per-user-scheduling/10-02-SUMMARY.md`
</output>
